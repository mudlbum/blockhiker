<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Quest: Elements & Weather</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }
        canvas {
            display: block;
        }
        /* HUD */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 20px;
            text-shadow: 2px 2px 0 #000;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: none;
            z-index: 50;
        }
        .stat-bar {
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 5px;
            border: 2px solid #555;
        }
        
        /* HP Bar Style */
        .hp-container {
            min-width: 150px;
        }
        .hp-text {
            display: flex; 
            justify-content: space-between; 
            color: #ff5252; 
            font-size: 16px; 
            margin-bottom: 3px;
            font-weight: bold;
        }
        .hp-gauge-bg {
            width: 100%; 
            height: 10px; 
            background: #330000; 
            border: 1px solid #ff5252;
        }
        #ui-hp-bar {
            width: 100%; 
            height: 100%; 
            background: #ff5252; 
            transition: width 0.2s;
        }

        /* Inventory Bar */
        #ui-layer {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 12px;
            pointer-events: none;
            z-index: 50;
        }
        .slot {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #555;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.1s;
        }
        .slot.active {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.2);
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
            z-index: 10;
        }
        .slot-key {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 10px;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
        }
        .block-preview {
            width: 32px;
            height: 32px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }
        .item-icon {
            font-size: 24px; 
            text-shadow: 2px 2px 0px #000;
        }

        /* Shop / Menu Overlay */
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none; /* Hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }
        .shop-container {
            background: #333;
            padding: 30px;
            border-radius: 15px;
            border: 4px solid #4caf50;
            text-align: center;
            max-width: 600px;
        }
        .shop-title {
            font-size: 32px;
            margin-bottom: 20px;
            color: #FFD700;
            text-transform: uppercase;
        }
        .shop-items {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        .shop-btn {
            background: #555;
            border: 2px solid #777;
            color: white;
            padding: 15px;
            cursor: pointer;
            border-radius: 8px;
            font-size: 14px;
            transition: 0.2s;
        }
        .shop-btn:hover { background: #666; border-color: #fff; }
        .shop-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .action-row {
            display: flex;
            gap: 10px;
            width: 100%;
            margin-top: 10px;
        }
        .next-level-btn {
            background: #2e7d32;
            border-color: #4caf50;
            flex: 2;
            font-weight: bold;
            font-size: 20px;
            padding: 15px;
        }
        .next-level-btn:hover { background: #388e3c; }
        .save-btn {
            background: #1976D2;
            flex: 1;
        }

        .death-screen {
            color: #ff5252;
        }
        
        #boss-hud {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            display: none;
            z-index: 40;
        }
        .boss-name {
            color: #FF4081;
            text-align: center;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            margin-bottom: 5px;
        }
        .boss-bar-bg {
            width: 100%;
            height: 20px;
            background: #333;
            border: 2px solid #fff;
        }
        .boss-bar-fill {
            width: 100%;
            height: 100%;
            background: #FF4081;
            transition: width 0.2s;
        }
        #breath-bar {
            width: 0%;
            height: 10px;
            background: #00B0FF;
            transition: width 0.1s;
            margin-top: 5px;
            display: none;
        }
    </style>
</head>
<body>

    <!-- Heads Up Display -->
    <div id="hud">
        <div class="stat-bar">LEVEL: <span id="ui-level">1</span></div>
        <div class="stat-bar" style="color:#FFD700;">GOLD: $<span id="ui-gold">0</span></div>
        
        <!-- Improved HP Bar -->
        <div class="stat-bar hp-container">
            <div class="hp-text">
                <span>HP</span>
                <span><span id="ui-hp">100</span>/<span id="ui-max-hp">100</span></span>
            </div>
            <div class="hp-gauge-bg">
                <div id="ui-hp-bar"></div>
            </div>
        </div>

        <div id="breath-container" class="stat-bar" style="display:none; border-color: #00B0FF;">
             O2: <div id="breath-bar" style="display:block; width:100%;"></div>
        </div>
    </div>
    
    <div id="boss-hud">
        <div class="boss-name">BOSS</div>
        <div class="boss-bar-bg"><div class="boss-bar-fill" id="boss-hp-bar"></div></div>
    </div>

    <!-- Shop / Game Over Overlay -->
    <div id="overlay">
        <div class="shop-container" id="shop-menu">
            <div class="shop-title">Level Complete!</div>
            <div style="margin-bottom: 20px;">Current Gold: <span id="shop-gold" style="color:#FFD700; font-weight:bold;">0</span></div>
            
            <div class="shop-items">
                <button class="shop-btn" onclick="buyItem('heal')">
                    ‚ù§Ô∏è Heal (50g)<br><small>+50 HP</small>
                </button>
                <button class="shop-btn" onclick="buyItem('damage')">
                    ‚öîÔ∏è Sharpen (200g)<br><small>+10 Dmg</small>
                </button>
                <button class="shop-btn" onclick="buyItem('speed')">
                    üëü Boots (150g)<br><small>+Speed</small>
                </button>
                <button class="shop-btn" onclick="buyItem('maxhp')">
                    üõ°Ô∏è Armor (300g)<br><small>+50 Max HP</small>
                </button>
                <button class="shop-btn" onclick="buyItem('wand')" id="btn-wand">
                    üî• Fire Wand (500g)<br><small>Explosive Ranged</small>
                </button>
                <button class="shop-btn" disabled>
                     üîí Locked<br><small>Coming Soon</small>
                </button>
            </div>

            <div class="action-row">
                <button class="shop-btn save-btn" onclick="saveGame()">üíæ Save</button>
                <button class="shop-btn save-btn" onclick="document.getElementById('load-input').click()">üìÇ Load</button>
                <button class="shop-btn next-level-btn" onclick="nextLevel()">Next Level >></button>
            </div>
            <input type="file" id="load-input" style="display:none" onchange="loadGame(this)">
        </div>

        <div class="shop-container" id="death-menu" style="display:none; border-color: #d32f2f;">
            <div class="shop-title death-screen">YOU DIED</div>
            <p>You fell, drowned, or burned.</p>
            <p>Restarting Level <span id="death-level">1</span></p>
            <button class="shop-btn" onclick="restartGame()">Try Again</button>
        </div>
    </div>

    <div id="ui-layer">
        <!-- Slots injected by JS -->
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    // --- Configuration ---
    const TILE_SIZE = 40;
    const GRAVITY = 0.5;
    const TERMINAL_VELOCITY = 15;
    let JUMP_FORCE = -11;
    const INTERACTION_RANGE = 5 * TILE_SIZE; // 5 Blocks

    // --- ID Registry ---
    const BLOCKS = {
        AIR: 0, DIRT: 1, GRASS: 2, STONE: 3, WOOD: 4, LEAVES: 5, BRICK: 6,
        SAND: 7, SNOW: 8, COAL_ORE: 9, GOLD_ORE: 10, DIAMOND_ORE: 11,
        TNT: 12, GLASS: 13, PLANK: 14, SPIKE: 15, GOAL: 99,
        WATER: 20, LAVA: 21
    };
    
    const ITEMS = { SWORD: 100, WAND: 101 };

    const BLOCK_DEF = {
        [BLOCKS.DIRT]: { color: '#5d4037' },
        [BLOCKS.GRASS]: { color: '#5d4037', top: '#4caf50' },
        [BLOCKS.STONE]: { color: '#757575' },
        [BLOCKS.WOOD]: { color: '#5d4037', side: '#4e342e' },
        [BLOCKS.LEAVES]: { color: '#2e7d32', alpha: 0.9 },
        [BLOCKS.BRICK]: { color: '#b71c1c' },
        [BLOCKS.SAND]: { color: '#fbc02d' },
        [BLOCKS.SNOW]: { color: '#e0f7fa', top: '#ffffff' },
        [BLOCKS.COAL_ORE]: { color: '#757575', speckle: '#212121', value: 5 },
        [BLOCKS.GOLD_ORE]: { color: '#757575', speckle: '#ffeb3b', value: 15 },
        [BLOCKS.DIAMOND_ORE]: { color: '#757575', speckle: '#00bcd4', value: 50 },
        [BLOCKS.TNT]: { color: '#d32f2f', label: 'TNT' },
        [BLOCKS.GLASS]: { color: '#81d4fa', alpha: 0.4 },
        [BLOCKS.PLANK]: { color: '#8d6e63' },
        [BLOCKS.SPIKE]: { color: '#9E9E9E', spike: true },
        [BLOCKS.WATER]: { color: '#29B6F6', alpha: 0.5, fluid: true },
        [BLOCKS.LAVA]: { color: '#FF5722', alpha: 0.8, fluid: true, light: true },
        [BLOCKS.GOAL]: { color: '#6a1b9a', speckle: '#FFD700' }, 
        [ITEMS.SWORD]: { icon: 'üó°Ô∏è', type: 'tool', color: '#00bcd4' },
        [ITEMS.WAND]: { icon: 'üî•', type: 'tool', color: '#FF5722' }
    };

    // --- Global Game State ---
    let gameState = "PLAY"; 
    let currentLevel = 1;
    let worldWidth = 100;
    let worldHeight = 50;
    
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let width, height;

    let world = [];
    let particles = [];
    let mobs = [];
    let projectiles = [];
    let activeTNTs = []; // List of ignited TNT
    let gameTime = 0; 
    let shake = 0;
    let damageFlash = 0; // Visual red flash intensity
    
    // Weather
    let weather = "NONE"; // NONE, RAIN, SNOW
    let weatherParticles = [];

    // --- Player ---
    const player = {
        x: 0, y: 0,
        width: 28, height: 38,
        vx: 0, vy: 0,
        grounded: false,
        facingRight: true,
        attackTimer: 0,
        actionTimer: 0,
        hp: 100, maxHp: 100,
        gold: 10, speed: 6, damage: 15, // Start with 10 gold
        hasWand: false,
        breath: 100,
        inWater: false,
        invulnerable: 0
    };

    const camera = { x: 0, y: 0 };
    
    let inventory = [
        ITEMS.SWORD, BLOCKS.DIRT, BLOCKS.STONE, BLOCKS.WOOD, BLOCKS.PLANK, 
        BLOCKS.TNT, BLOCKS.GLASS, BLOCKS.WATER, BLOCKS.LAVA
    ];
    let selectedBlockIndex = 0;

    const keys = {};
    const mouse = { x: 0, y: 0, leftDown: false, rightDown: false };

    // --- Mobs ---
    const MOB_TYPES = {
        SLIME: { color: '#76ff03', width: 30, height: 20, speed: 2, jump: -8, hp: 30, reward: 10, type: 'slime' },
        ZOMBIE: { color: '#2e7d32', width: 28, height: 38, speed: 1.5, jump: -10, hp: 50, reward: 20, type: 'zombie' },
        BAT: { color: '#424242', width: 20, height: 20, speed: 3, jump: 0, hp: 20, reward: 15, type: 'bat', fly: true },
        BOSS_SLIME: { color: '#00E676', width: 90, height: 90, speed: 3, jump: -14, hp: 600, reward: 500, type: 'boss', name: "KING SLIME" },
        BOSS_ZOMBIE: { color: '#D50000', width: 60, height: 100, speed: 4, jump: -12, hp: 800, reward: 600, type: 'boss', name: "MUTANT ZOMBIE" },
        BOSS_VOID: { color: '#212121', width: 100, height: 120, speed: 2, jump: -10, hp: 1200, reward: 1000, type: 'boss', name: "VOID LORD" }
    };

    let activeBoss = null;

    // --- Initialization ---
    function init() {
        resize();
        window.addEventListener('resize', resize);
        generateLevel(1);
        setupUI();
        updateHUD();
        
        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if(gameState === "PLAY") {
                const num = parseInt(e.key);
                if (!isNaN(num) && num >= 1 && num <= 9) selectSlot(num - 1);
            }
        });
        window.addEventListener('keyup', e => keys[e.code] = false);
        
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });
        
        canvas.addEventListener('mousedown', e => {
            if (e.button === 0) mouse.leftDown = true;
            if (e.button === 2) mouse.rightDown = true;
        });
        
        canvas.addEventListener('mouseup', e => {
            if (e.button === 0) mouse.leftDown = false;
            if (e.button === 2) mouse.rightDown = false;
        });

        canvas.addEventListener('contextmenu', e => e.preventDefault());

        requestAnimationFrame(loop);
    }

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }

    // --- Level Generation ---
    function generateLevel(level) {
        world = [];
        particles = [];
        mobs = [];
        projectiles = [];
        weatherParticles = [];
        activeTNTs = [];
        player.vx = 0; player.vy = 0;
        player.breath = 100;
        activeBoss = null;
        document.getElementById('boss-hud').style.display = 'none';
        
        // Random Weather
        let wRand = Math.random();
        if (wRand < 0.2) weather = "RAIN";
        else if (wRand < 0.4 && level > 2) weather = "SNOW";
        else weather = "NONE";

        // Infinite Scaling
        worldWidth = 150 + (level * 20); 
        worldHeight = 60;
        const mobChance = Math.min(0.05, 0.02 + (level * 0.005)); 

        const heights = [];
        for (let x = 0; x < worldWidth; x++) {
            let base = Math.sin(x * 0.05) * (5 + level * 2); 
            let detail = Math.sin(x * 0.3) * (2 + level);
            let h = Math.floor(worldHeight / 2 + base + detail);
            // Clamp Height to prevent OOB
            if(h < 5) h = 5;
            if(h > worldHeight - 5) h = worldHeight - 5;
            heights.push(h);
        }

        const isBossLevel = level % 3 === 0;

        // Calculate dirt depths
        let dirtDepths = [];
        let currDepth = 4;
        for(let x=0; x<worldWidth; x++) {
            let change = Math.floor(Math.random() * 5) - 2; 
            currDepth += change;
            if (currDepth < 0) currDepth = 0;
            if (currDepth > 5) currDepth = 5;
            dirtDepths.push(currDepth);
        }

        for (let y = 0; y < worldHeight; y++) {
            let row = [];
            for (let x = 0; x < worldWidth; x++) {
                let h = heights[x];
                let dDepth = dirtDepths[x];
                let block = BLOCKS.AIR;

                if (x < 20) {
                    h = Math.floor(worldHeight / 2);
                    if (y >= h) block = (y === h) ? BLOCKS.GRASS : BLOCKS.DIRT;
                    if (y >= worldHeight - 2) block = BLOCKS.BRICK;
                } else {
                    let isGap = false;
                    if (isBossLevel && x > worldWidth - 60) h = Math.floor(worldHeight/2);
                    else if (x < worldWidth - 20) {
                         let gapNoise = Math.sin(x * 0.8) * Math.cos(x * 0.4);
                         if (gapNoise > (0.9 - (level * 0.02))) isGap = true;
                    }

                    if (isGap && y > worldHeight - 5) {
                        block = (Math.random() < 0.5) ? BLOCKS.SPIKE : BLOCKS.LAVA;
                    } else if (!isGap && y >= h) {
                        if (y === h) block = BLOCKS.GRASS;
                        else if (y > h && y <= h + dDepth) block = BLOCKS.DIRT; 
                        else block = BLOCKS.STONE;
                        
                        if (block === BLOCKS.STONE) {
                            let r = Math.random();
                            if (r < 0.05) block = BLOCKS.COAL_ORE;
                            else if (r < 0.03) block = BLOCKS.GOLD_ORE;
                            else if (r < 0.02) block = BLOCKS.DIAMOND_ORE;
                        }
                    }
                    if (y >= worldHeight - 2) block = BLOCKS.BRICK;
                }
                
                // One Block Portal
                if (x === worldWidth - 4 && y === h - 1) block = BLOCKS.GOAL;
                if (x > worldWidth - 10 && y >= h && block === BLOCKS.AIR) block = BLOCKS.STONE;

                row.push(block);
            }
            world.push(row);
        }

        // Ponds Generation (Flat Top Ellipse, Non-destructive)
        let numPonds = Math.floor(Math.random() * 4); // 0 to 3
        for(let i=0; i<numPonds; i++) {
            let pW = 7 + Math.floor(Math.random() * 6); // 7 to 12
            let pD = 3 + Math.floor(Math.random() * 3); // 3 to 5
            
            let startX = 25 + Math.floor(Math.random() * (worldWidth - 50));
            if (isBossLevel && startX > worldWidth - 70) continue; 

            // Find surface height at the center of the potential pond
            let centerIdx = startX + Math.floor(pW/2);
            // Safety check for index
            if (centerIdx >= heights.length) continue;
            let surfaceY = heights[centerIdx];
            
            // Ellipse center
            let cX = startX + pW / 2;
            let cY = surfaceY; 
            let rX = pW / 2;
            let rY = pD;

            for (let x = startX; x < startX + pW; x++) {
                if (x >= worldWidth - 10) continue;
                
                // Calculate max depth at this x from ellipse
                let xDist = (x - cX);
                let yDist = rY * Math.sqrt(1 - (xDist*xDist)/(rX*rX));
                
                if (isNaN(yDist)) continue;
                let maxY = Math.floor(cY + yDist);

                // Dig and fill only (Do not clear air above)
                for (let y = surfaceY; y <= maxY; y++) {
                    if (y < 0 || y >= worldHeight - 2) continue; // Boundary check
                    
                    // Boundary check for x is handled by loop and array gen
                    if (!world[y]) continue; // Safety check for row existence

                    let existing = world[y][x];
                    // Only replace solid blocks with water (avoids floating water)
                    // And do not replace special blocks
                    if (existing !== BLOCKS.AIR && existing !== BLOCKS.GOAL && existing !== BLOCKS.BRICK) {
                        world[y][x] = BLOCKS.WATER;
                    }
                }
            }
        }

        // Mobs Generation (First pass)
        for (let x = 20; x < worldWidth - 20; x++) {
            if (isBossLevel && x > worldWidth - 60) continue;
            if (Math.random() < mobChance) {
                let h = heights[x];
                // Ground Mobs
                if (world[h][x] !== BLOCKS.AIR && world[h-1][x] === BLOCKS.AIR) {
                    let type = (Math.random() < 0.6) ? 'SLIME' : 'ZOMBIE';
                    spawnMob(x * TILE_SIZE, (h - 2) * TILE_SIZE, type);
                }
                // Flying Mobs
                if (level > 2 && Math.random() < 0.3) {
                     spawnMob(x * TILE_SIZE, (h - 10) * TILE_SIZE, 'BAT');
                }
            }
        }

        // Ensure minimum 3 mobs
        while (mobs.length < 3) {
            let rx = 20 + Math.floor(Math.random() * (worldWidth - 40));
            if (isBossLevel && rx > worldWidth - 60) continue;
            let rh = heights[rx];
            if (world[rh][rx] !== BLOCKS.AIR && world[rh-1][rx] === BLOCKS.AIR) {
                spawnMob(rx * TILE_SIZE, (rh - 2) * TILE_SIZE, 'SLIME');
            }
        }

        if (isBossLevel) {
            let bx = (worldWidth - 30) * TILE_SIZE;
            let bossType = 'BOSS_SLIME';
            if (level % 9 === 3) bossType = 'BOSS_SLIME';
            else if (level % 9 === 6) bossType = 'BOSS_ZOMBIE';
            else if (level % 9 === 0) bossType = 'BOSS_VOID';
            spawnMob(bx, 0, bossType);
        }

        player.x = 5 * TILE_SIZE;
        player.y = 0; 
        
        gameState = "PLAY";
        document.getElementById('overlay').style.display = 'none';
        updateHUD();
    }

    function spawnMob(x, y, typeKey) {
        let stats = MOB_TYPES[typeKey];
        let hpScale = stats.hp + (currentLevel * 10);
        let m = {
            x: x, y: y,
            vx: 0, vy: 0,
            ...stats,
            maxHp: hpScale,
            hp: hpScale,
            grounded: false,
            hurtTimer: 0
        };
        mobs.push(m);
        if (stats.type === 'boss') {
            activeBoss = m;
            // Removed direct show here
            document.querySelector('.boss-name').innerText = stats.name;
        }
    }

    // --- Game Logic ---
    function loop() {
        if (gameState === "PLAY") {
            update();
        }
        draw();
        requestAnimationFrame(loop);
    }

    function update() {
        gameTime++;
        if(shake > 0) shake *= 0.9;
        if(shake < 0.5) shake = 0;
        if(player.invulnerable > 0) player.invulnerable--;

        // Weather Particles
        if (weather === "RAIN") {
            if (Math.random() < 0.5) weatherParticles.push({x: Math.random()*width, y: -10, vy: 15 + Math.random()*5, type: 'rain'});
        } else if (weather === "SNOW") {
            if (Math.random() < 0.2) weatherParticles.push({x: Math.random()*width, y: -10, vy: 2 + Math.random(), vx: Math.random()-0.5, type: 'snow'});
        }
        
        // Physics
        let blockAtFeet = getBlock(Math.floor((player.x + player.width/2)/TILE_SIZE), Math.floor((player.y + player.height/2)/TILE_SIZE));
        player.inWater = (blockAtFeet === BLOCKS.WATER);
        let inLava = (blockAtFeet === BLOCKS.LAVA);

        // Movement
        let moveSpeed = player.speed;
        if (player.inWater) moveSpeed *= 0.5;
        if (inLava) moveSpeed *= 0.1; // Extremely slow in lava

        if (keys['KeyA'] || keys['ArrowLeft']) { player.vx = -moveSpeed; player.facingRight = false; }
        else if (keys['KeyD'] || keys['ArrowRight']) { player.vx = moveSpeed; player.facingRight = true; }
        else player.vx = 0;

        if (keys['Space'] || keys['ArrowUp'] || keys['KeyW']) {
            if (player.inWater) {
                // Modified Jump Logic for Water Surface
                let headBlockX = Math.floor((player.x + player.width/2)/TILE_SIZE);
                let headBlockY = Math.floor((player.y)/TILE_SIZE);
                let blockAboveHead = getBlock(headBlockX, headBlockY - 1);
                
                // If head is near surface (block above is air), allow jump
                if (blockAboveHead === BLOCKS.AIR) {
                    player.vy = JUMP_FORCE * 0.5; // Half jump height on water
                } else {
                    player.vy = -3; // Regular swim
                }
            } else if (player.grounded) {
                player.vy = JUMP_FORCE;
                player.grounded = false;
            }
        }

        // Gravity / Drag
        if (player.inWater) {
             player.vy += 0.1; // Low gravity
             if(player.vy > 3) player.vy = 3;
             player.breath -= 0.5;
             if(player.breath <= 0 && gameTime % 30 === 0) takeDamage(5);
        } else {
             player.vy += GRAVITY;
             player.breath = Math.min(player.breath + 1, 100);
        }
        
        // Lava Damage
        if (inLava && gameTime % 30 === 0) takeDamage(10);

        if (player.vy > TERMINAL_VELOCITY) player.vy = TERMINAL_VELOCITY;
        if (player.attackTimer > 0) player.attackTimer--;
        if (player.actionTimer > 0) player.actionTimer--;

        player.x += player.vx;
        checkEntityCollision(player, 'x');
        player.y += player.vy;
        player.grounded = false;
        checkEntityCollision(player, 'y');

        // Continuous Interaction (Drag)
        if (gameState === "PLAY") {
            if (mouse.leftDown) handleInteraction(0);
            if (mouse.rightDown) handleInteraction(2);
        }

        // Goal
        let px = Math.floor((player.x + player.width/2) / TILE_SIZE);
        let py = Math.floor((player.y + player.height/2) / TILE_SIZE);
        if (getBlock(px, py) === BLOCKS.GOAL) {
            completeLevel();
        }

        if (player.y > worldHeight * TILE_SIZE + 100) die();
        if (player.hp <= 0) die();

        // Camera
        let targetCamX = player.x + player.width / 2 - width / 2;
        let targetCamY = player.y + player.height / 2 - height / 2;
        camera.x += (targetCamX - camera.x) * 0.1;
        camera.y += (targetCamY - camera.y) * 0.1;

        updateMobs();
        updateProjectiles();
        updateParticles();
        updateTNTs();
        updateHUD(); // For breath bar
    }

    function updateTNTs() {
        for (let i = activeTNTs.length - 1; i >= 0; i--) {
            let tnt = activeTNTs[i];
            tnt.timer--;
            if (tnt.timer % 20 === 0) {
                // Smoke effect while waiting
                spawnParticles(tnt.x, tnt.y, '#fff', 1);
            }
            if (tnt.timer <= 0) {
                explode(tnt.x, tnt.y, 4);
                activeTNTs.splice(i, 1);
            }
        }
    }

    function updateMobs() {
        if (activeBoss) {
            // Boss Bar Range Check
            let distToBoss = Math.abs(player.x - activeBoss.x);
            let hud = document.getElementById('boss-hud');
            
            if (distToBoss < 800 && activeBoss.hp > 0) {
                hud.style.display = 'block';
                let pct = (activeBoss.hp / activeBoss.maxHp) * 100;
                document.getElementById('boss-hp-bar').style.width = pct + '%';
            } else {
                hud.style.display = 'none';
            }
        }

        for (let i = mobs.length - 1; i >= 0; i--) {
            let m = mobs[i];
            
            let dist = player.x - m.x;
            let distY = player.y - m.y;
            let range = 600;
            
            // Check Mob Environment (Water/Lava)
            let mCx = Math.floor((m.x + m.width/2) / TILE_SIZE);
            let mCy = Math.floor((m.y + m.height/2) / TILE_SIZE);
            let mBlock = getBlock(mCx, mCy);
            
            // Mob Movement Modifiers
            let speedMult = 1.0;
            
            // Water Effect on Mobs
            if (mBlock === BLOCKS.WATER) {
                speedMult = 0.5;
                m.vy = Math.min(m.vy, 2); // Slow fall
            } 
            // Lava Effect on Mobs
            else if (mBlock === BLOCKS.LAVA) {
                speedMult = 0.1;
                if (gameTime % 30 === 0) {
                    m.hp -= 10;
                    m.hurtTimer = 10;
                    // Visual feedback
                    spawnParticles(mCx, mCy, '#ff0000', 2);
                }
            }

            if (Math.abs(dist) < range) {
                if(m.type === 'bat') {
                    // Bat AI: Swoop
                    m.vx = (dist > 0 ? 1 : -1) * m.speed;
                    m.vy = (distY > 0 ? 1 : -1) * 1.5;
                } else if (m.type === 'boss') {
                    if (dist > 10) m.vx = m.speed * speedMult;
                    else if (dist < -10) m.vx = -m.speed * speedMult;
                    if (m.grounded && Math.random() < 0.02) {
                        m.vy = m.jump;
                        shake = 5; 
                    }
                } else {
                    // Standard Walker
                    if (dist > 10) m.vx = m.speed * speedMult;
                    else if (dist < -10) m.vx = -m.speed * speedMult;
                    if (m.vx !== 0 && isBlocked(m) && m.grounded) m.vy = m.jump;
                }
                
                if (checkRectOverlap(player, m)) {
                    if (gameTime % 20 === 0) {
                        let dmg = 5 + currentLevel;
                        if (m.type === 'boss') dmg = 20 + currentLevel;
                        takeDamage(dmg);
                        player.vx = (player.x < m.x ? -10 : 10);
                        player.vy = -5;
                        shake = 5;
                    }
                }
            } else {
                if(!m.fly) m.vx *= 0.9;
            }

            if(!m.fly) {
                // Apply Gravity if not flying (and handle fluid physics above)
                if (mBlock === BLOCKS.WATER) m.vy += 0.1;
                else m.vy += GRAVITY;
            }
            
            m.x += m.vx;
            checkEntityCollision(m, 'x');
            m.y += m.vy;
            m.grounded = false;
            checkEntityCollision(m, 'y');

            if (m.hurtTimer > 0) m.hurtTimer--;

            if (m.y > worldHeight * TILE_SIZE + 100) {
                 mobs.splice(i, 1); 
            } else if (m.hp <= 0) {
                spawnParticles(m.x/TILE_SIZE, m.y/TILE_SIZE, m.color, 30);
                addGold(m.reward);
                spawnFloatingText(m.x, m.y, `+${m.reward}g`, '#FFD700');
                if (m.type === 'boss') {
                    activeBoss = null;
                    document.getElementById('boss-hud').style.display = 'none';
                    shake = 20; 
                }
                mobs.splice(i, 1);
            }
        }
    }

    function updateProjectiles() {
        for (let i = projectiles.length - 1; i >= 0; i--) {
            let p = projectiles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.2; 
            p.life--;

            let tx = Math.floor(p.x / TILE_SIZE);
            let ty = Math.floor(p.y / TILE_SIZE);
            let b = getBlock(tx, ty);
            // Don't explode on fluid
            let bDef = BLOCK_DEF[b] || {};
            if ((b !== BLOCKS.AIR && !bDef.fluid) || p.life <= 0) {
                explode(tx, ty, 2); 
                projectiles.splice(i, 1);
                continue;
            }

            for (let m of mobs) {
                if (p.x > m.x && p.x < m.x + m.width && p.y > m.y && p.y < m.y + m.height) {
                    m.hp -= 30 + (player.damage); 
                    m.hurtTimer = 10;
                    spawnParticles(m.x/TILE_SIZE, m.y/TILE_SIZE, '#FF5722', 10);
                    explode(Math.floor(p.x/TILE_SIZE), Math.floor(p.y/TILE_SIZE), 1.5);
                    projectiles.splice(i, 1);
                    break;
                }
            }
        }
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx; p.y += p.vy; p.vy += 0.2; p.life--;
            if (p.life <= 0) particles.splice(i, 1);
        }
        
        for (let i = weatherParticles.length - 1; i >= 0; i--) {
            let p = weatherParticles[i];
            
            // Move opposite to player for parallax
            p.x += (p.vx || 0) - player.vx; 
            p.y += p.vy;
            
            if(p.y > height) weatherParticles.splice(i, 1);
        }
    }

    function checkRectOverlap(a, b) {
        return (a.x < b.x + b.width && a.x + a.width > b.x &&
                a.y < b.y + b.height && a.y + a.height > b.y);
    }

    function isBlocked(entity) {
        let tx = Math.floor((entity.x + (entity.vx > 0 ? entity.width + 5 : -5)) / TILE_SIZE);
        let ty = Math.floor((entity.y + entity.height - 5) / TILE_SIZE);
        let b = getBlock(tx, ty);
        let def = BLOCK_DEF[b] || {};
        return b !== BLOCKS.AIR && !def.fluid;
    }

    function checkEntityCollision(ent, axis) {
        let left = Math.floor(ent.x / TILE_SIZE);
        let right = Math.floor((ent.x + ent.width - 0.01) / TILE_SIZE);
        let top = Math.floor(ent.y / TILE_SIZE);
        let bottom = Math.floor((ent.y + ent.height - 0.01) / TILE_SIZE);

        for (let y = top; y <= bottom; y++) {
            for (let x = left; x <= right; x++) {
                let b = getBlock(x, y);

                // FIX: Check for AIR before accessing definition
                if (b === BLOCKS.AIR) continue;
                
                // FIX: Ensure definition exists
                let def = BLOCK_DEF[b];
                if (!def) continue;

                // Fluid/Spike logic
                if (def.fluid) continue; // No collision with fluids
                
                if (b === BLOCKS.SPIKE) {
                    if (ent === player) {
                         takeDamage(10);
                         ent.vy = -10; 
                         shake = 5;
                    }
                }
                
                if (b !== BLOCKS.GOAL && b !== BLOCKS.SPIKE && !def.alpha) {
                    if (axis === 'x') {
                        if (ent.vx > 0) ent.x = x * TILE_SIZE - ent.width;
                        else if (ent.vx < 0) ent.x = (x + 1) * TILE_SIZE;
                        ent.vx = 0;
                    } else {
                        if (ent.vy > 0) {
                            ent.y = y * TILE_SIZE - ent.height;
                            ent.grounded = true;
                            ent.vy = 0;
                        } else if (ent.vy < 0) {
                            ent.y = (y + 1) * TILE_SIZE;
                            ent.vy = 0;
                        }
                    }
                    return;
                }
            }
        }
    }

    function takeDamage(amount) {
        if(player.invulnerable > 0) return;
        player.hp -= amount;
        player.invulnerable = 15;
        damageFlash = 0.6; // Trigger flash
        updateHUD();
        spawnFloatingText(player.x, player.y, `-${amount}`, '#ff0000');
    }

    function die() {
        gameState = "DEAD";
        document.getElementById('overlay').style.display = 'flex';
        document.getElementById('shop-menu').style.display = 'none';
        document.getElementById('death-menu').style.display = 'block';
        document.getElementById('death-level').innerText = currentLevel;
    }

    function completeLevel() {
        if(gameState === "SHOP") return;
        gameState = "SHOP";
        addGold(100); 
        document.getElementById('overlay').style.display = 'flex';
        document.getElementById('shop-menu').style.display = 'block';
        document.getElementById('death-menu').style.display = 'none';
        document.getElementById('shop-gold').innerText = player.gold;
    }

    // --- Interaction ---
    function handleInteraction(button) {
        if (player.actionTimer > 0) return;
        
        let mx = mouse.x + camera.x;
        let my = mouse.y + camera.y;
        let tx = Math.floor(mx / TILE_SIZE);
        let ty = Math.floor(my / TILE_SIZE);

        let dist = Math.hypot(player.x + player.width/2 - mx, player.y + player.height/2 - my);

        let selected = inventory[selectedBlockIndex];

        // Tools (Sword/Wand) work anywhere (ranged) or close (melee)
        if (button === 0 && (selected === ITEMS.SWORD || selected === ITEMS.WAND)) {
            if (player.attackTimer <= 0) {
                 if (selected === ITEMS.SWORD) performAttack();
                 else shootWand(mx, my);
                 player.actionTimer = 10;
            }
            return;
        }
        
        // Range Check for Building/Mining
        if (dist > INTERACTION_RANGE) return;

        player.actionTimer = 8; 

        if (button === 0) { // Mine
            let current = getBlock(tx, ty);
            if (current === BLOCKS.TNT) {
                // If block is TNT, we want to trigger it (ignite)
                let cost = 0; // Already paid
                setBlock(tx, ty, BLOCKS.AIR);
                activeTNTs.push({ x: tx, y: ty, timer: 120 }); // 2 sec delay
                spawnFloatingText(mx, my, "Ignited!", "#ff5252");
            }
            else if (current !== BLOCKS.AIR && current !== BLOCKS.GOAL) {
                if (player.gold >= 1) {
                    player.gold -= 1;
                    updateHUD();
                    spawnFloatingText(mx, my, "-1g", "#ffff00");

                    let def = BLOCK_DEF[current] || {};
                    if (def.value) {
                         addGold(def.value); 
                         spawnFloatingText(mx, my - 20, `+$${def.value}`, '#FFD700');
                    }
                    if (def.color) spawnParticles(tx, ty, def.color);
                    setBlock(tx, ty, BLOCKS.AIR);
                } else {
                    spawnFloatingText(mx, my, "Need Gold!", "#ff0000");
                }
            }
        } else if (button === 2) { // Place
            if (selected !== ITEMS.SWORD && selected !== ITEMS.WAND) {
                let px = player.x / TILE_SIZE;
                let py = player.y / TILE_SIZE;
                let pw = player.width / TILE_SIZE;
                let ph = player.height / TILE_SIZE;
                
                // Don't place inside player
                if (!(tx >= px + pw || tx + 1 <= px || ty >= py + ph || ty + 1 <= py)) return;
                
                let current = getBlock(tx, ty);
                let def = BLOCK_DEF[current] || {};
                
                // --- Fix: Do not charge gold if placing the same block on itself ---
                if (current === selected) return;

                if (current === BLOCKS.AIR || def.alpha) {
                    let cost = 1;
                    if (selected === BLOCKS.WATER) cost = 5;
                    else if (selected === BLOCKS.LAVA) cost = 30;
                    else if (selected === BLOCKS.TNT) cost = 10;

                    if (player.gold >= cost) {
                        player.gold -= cost;
                        updateHUD();
                        spawnFloatingText(mx, my, `-${cost}g`, "#ffff00");
                        setBlock(tx, ty, selected);
                    } else {
                        spawnFloatingText(mx, my, "Need Gold!", "#ff0000");
                    }
                }
            }
        }
    }

    function shootWand(mx, my) {
        let angle = Math.atan2(my - (player.y + 10), mx - (player.x + 10));
        projectiles.push({
            x: player.x + 10,
            y: player.y + 10,
            vx: Math.cos(angle) * 10,
            vy: Math.sin(angle) * 10,
            life: 60
        });
    }

    function performAttack() {
        player.attackTimer = 15;
        // Hitbox centered on player but wider
        let reach = 80;
        let hitX = player.x + player.width/2 - reach/2;
        if (player.facingRight) hitX = player.x + player.width/2 - 10;
        else hitX = player.x + player.width/2 - reach + 10;

        let hitY = player.y - 10;
        let hitW = reach;
        let hitH = player.height + 20;

        mobs.forEach(m => {
            if (hitX < m.x + m.width && hitX + hitW > m.x &&
                hitY < m.y + m.height && hitY + hitH > m.y) {
                
                m.hp -= player.damage;
                m.hurtTimer = 10;
                m.vy = -5;
                m.vx = player.facingRight ? 8 : -8;
                spawnParticles(m.x/TILE_SIZE, m.y/TILE_SIZE, '#fff', 5);
                spawnFloatingText(m.x, m.y, player.damage, '#fff');
                shake = 2; 
            }
        });
    }

    function explode(cx, cy, radius) {
        setBlock(cx, cy, BLOCKS.AIR);
        spawnParticles(cx, cy, '#ff0000', 30);
        shake = radius * 2; 
        
        let r = Math.ceil(radius);
        // Ensure bounds are integers
        for (let y = cy - r; y <= cy + r; y++) {
            for (let x = cx - r; x <= cx + r; x++) {
                if ((x-cx)*(x-cx) + (y-cy)*(y-cy) <= radius*radius) {
                    let b = getBlock(x,y);
                    if (b !== BLOCKS.BRICK && b !== BLOCKS.GOAL) {
                        setBlock(x, y, BLOCKS.AIR);
                        if (Math.random() > 0.5) spawnParticles(x, y, '#555', 2);
                    }
                }
            }
        }
        
        // Damage Mobs
        mobs.forEach(m => {
            let dx = (m.x/TILE_SIZE) - cx;
            let dy = (m.y/TILE_SIZE) - cy;
            let dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < radius + 1) {
                // Damage based on distance
                let damageFactor = 1 - (dist / (radius + 2)); 
                if(damageFactor < 0) damageFactor = 0;
                m.hp -= 50 * damageFactor; 
                m.vy = -10;
            }
        });

        // Damage Player
        let pdx = (player.x/TILE_SIZE) - cx;
        let pdy = (player.y/TILE_SIZE) - cy;
        let pDist = Math.sqrt(pdx*pdx + pdy*pdy);
        if (pDist < radius + 1) {
            let damageFactor = 1 - (pDist / (radius + 2));
            takeDamage(Math.floor(25 * damageFactor));
            player.vx += (pdx / pDist) * 10; // Knockback
            player.vy += (pdy / pDist) * 10;
        }
    }

    function spawnParticles(tx, ty, color, count = 5) {
        for(let i=0; i<count; i++) {
            particles.push({
                x: tx * TILE_SIZE + TILE_SIZE/2,
                y: ty * TILE_SIZE + TILE_SIZE/2,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                life: 20 + Math.random() * 20,
                color: color,
                size: 4 + Math.random() * 4
            });
        }
    }
    
    let floatTexts = [];
    function spawnFloatingText(x, y, text, color) {
        floatTexts.push({ x, y, text, color, life: 40, vy: -1 });
    }

    // --- Save/Load ---
    function saveGame() {
        const data = {
            level: currentLevel,
            player: {
                hp: player.hp,
                maxHp: player.maxHp,
                gold: player.gold,
                speed: player.speed,
                damage: player.damage,
                hasWand: player.hasWand
            },
            inventory: inventory
        };
        const blob = new Blob([JSON.stringify(data)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `voxel_quest_lvl${currentLevel}.json`;
        a.click();
    }

    function loadGame(input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const data = JSON.parse(e.target.result);
                currentLevel = data.level;
                player.hp = data.player.hp;
                player.maxHp = data.player.maxHp;
                player.gold = data.player.gold;
                player.speed = data.player.speed;
                player.damage = data.player.damage;
                player.hasWand = data.player.hasWand;
                inventory = data.inventory;
                
                generateLevel(currentLevel);
                setupUI(); // Refresh slots (wand)
                updateHUD();
                
                // Close menu
                document.getElementById('overlay').style.display = 'none';
            } catch(err) {
                alert("Invalid Save File");
            }
        };
        reader.readAsText(file);
    }

    // --- Shop ---
    function addGold(amount) {
        player.gold += amount;
        updateHUD();
    }

    function updateHUD() {
        document.getElementById('ui-level').innerText = currentLevel;
        document.getElementById('ui-gold').innerText = Math.floor(player.gold);
        document.getElementById('ui-hp').innerText = Math.floor(player.hp);
        document.getElementById('ui-max-hp').innerText = player.maxHp;
        
        // Update HP Bar
        let hpPct = (player.hp / player.maxHp) * 100;
        document.getElementById('ui-hp-bar').style.width = Math.max(0, hpPct) + '%';

        let breathBar = document.getElementById('breath-bar');
        if (player.inWater) {
             document.getElementById('breath-container').style.display = 'block';
             breathBar.style.width = player.breath + '%';
        } else {
             document.getElementById('breath-container').style.display = 'none';
        }
    }

    window.buyItem = function(type) {
        let cost = 0;
        if (type === 'heal') cost = 50;
        if (type === 'damage') cost = 200;
        if (type === 'speed') cost = 150;
        if (type === 'maxhp') cost = 300;
        if (type === 'wand') cost = 500;

        if (player.gold >= cost) {
            if (type === 'wand' && player.hasWand) return; 

            player.gold -= cost;
            if (type === 'heal') player.hp = Math.min(player.hp + 50, player.maxHp);
            if (type === 'damage') player.damage += 10;
            if (type === 'speed') player.speed += 1;
            if (type === 'maxhp') { player.maxHp += 50; player.hp += 50; }
            if (type === 'wand') {
                player.hasWand = true;
                inventory.push(ITEMS.WAND);
                setupUI();
                document.getElementById('btn-wand').disabled = true;
                document.getElementById('btn-wand').innerHTML = "‚úÖ Owned";
            }

            updateHUD();
            document.getElementById('shop-gold').innerText = player.gold;
        } else {
            alert("Not enough gold!");
        }
    };

    window.nextLevel = function() {
        currentLevel++;
        generateLevel(currentLevel);
    };

    window.restartGame = function() {
        player.hp = player.maxHp;
        generateLevel(currentLevel);
    };

    // --- Utility ---
    function getBlock(x, y) {
        x = Math.floor(x);
        y = Math.floor(y);
        if (x >= 0 && x < worldWidth && y >= 0 && y < worldHeight) return world[y][x];
        return BLOCKS.AIR;
    }
    function setBlock(x, y, id) {
        x = Math.floor(x);
        y = Math.floor(y);
        if (x >= 0 && x < worldWidth && y >= 0 && y < worldHeight) world[y][x] = id;
    }

    function setupUI() {
        const ui = document.getElementById('ui-layer');
        ui.innerHTML = '';
        inventory.forEach((item, index) => {
            const slot = document.createElement('div');
            slot.className = 'slot';
            if (index === selectedBlockIndex) slot.classList.add('active');
            slot.onclick = () => selectSlot(index);
            
            const key = document.createElement('div');
            key.className = 'slot-key';
            key.innerText = index + 1;
            slot.appendChild(key);

            let def = BLOCK_DEF[item];
            if (def.icon) {
                 const icon = document.createElement('div');
                 icon.className = 'item-icon';
                 icon.innerText = def.icon;
                 slot.appendChild(icon);
            } else {
                const preview = document.createElement('div');
                preview.className = 'block-preview';
                preview.style.backgroundColor = def.color;
                if (def.top) preview.style.borderTop = `5px solid ${def.top}`;
                slot.appendChild(preview);
            }
            ui.appendChild(slot);
        });
    }

    function selectSlot(index) {
        if (index < 0 || index >= inventory.length) return;
        selectedBlockIndex = index;
        const slots = document.querySelectorAll('.slot');
        slots.forEach(s => s.classList.remove('active'));
        slots[index].classList.add('active');
    }

    // --- Drawing ---
    function draw() {
        let timeNorm = (Math.sin(gameTime * 0.001) + 1) / 2;
        let r, g, b;
        
        if (weather === "RAIN") { // Darker Sky
            r = 50; g = 60; b = 80;
        } else {
            r = Math.floor(135 * timeNorm); g = Math.floor(206 * timeNorm); b = Math.floor(235 * timeNorm);
            r = Math.max(20, r); g = Math.max(20, g); b = Math.max(50, b);
        }
        
        ctx.fillStyle = `rgb(${r},${g},${b})`;
        ctx.fillRect(0, 0, width, height);

        // Sun
        if (weather === "NONE") {
            ctx.fillStyle = timeNorm > 0.5 ? '#FFD700' : '#F4F6F0';
            let sunY = height/2 + Math.cos(gameTime * 0.001) * (height/2 + 50);
            let sunX = width/2 + Math.sin(gameTime * 0.001) * (width/2);
            ctx.beginPath(); ctx.arc(sunX, sunY, 40, 0, Math.PI * 2); ctx.fill();
        }

        // Parallax Mountains (Improved)
        ctx.fillStyle = weather === "RAIN" ? `rgba(0, 0, 0, 0.4)` : `rgba(0, 0, 0, 0.2)`;
        ctx.beginPath();
        ctx.moveTo(0, height);
        // Use finer step for smooth curve
        for(let i=0; i<=width; i+=10) {
            // Parallax effect: Scale camera x to shift noise slowly
            let wx = i + camera.x * 0.1; 
            let mh = 150 + Math.sin(wx * 0.005) * 50 + Math.sin(wx * 0.02) * 20; 
            ctx.lineTo(i, height - mh);
        }
        ctx.lineTo(width, height);
        ctx.fill();

        ctx.save();
        // Screen Shake
        let shakeX = (Math.random() - 0.5) * shake;
        let shakeY = (Math.random() - 0.5) * shake;
        ctx.translate(-Math.floor(camera.x) + shakeX, -Math.floor(camera.y) + shakeY);

        // Blocks
        const startCol = Math.floor(camera.x / TILE_SIZE);
        const endCol = startCol + (width / TILE_SIZE) + 2;
        const startRow = Math.floor(camera.y / TILE_SIZE);
        const endRow = startRow + (height / TILE_SIZE) + 2;

        for (let y = Math.max(0, startRow); y < Math.min(worldHeight, endRow); y++) {
            for (let x = Math.max(0, startCol); x < Math.min(worldWidth, endCol); x++) {
                let type = world[y][x];
                if (type !== BLOCKS.AIR) {
                    let def = BLOCK_DEF[type];
                    let px = x * TILE_SIZE;
                    let py = y * TILE_SIZE;
                    
                    if (type === BLOCKS.WATER) {
                        // Check if surface
                        let isSurface = getBlock(x, y-1) === BLOCKS.AIR;
                        
                        ctx.fillStyle = def.color;
                        if (isSurface) {
                            // Draw water body lower
                            ctx.fillRect(px, py + 6, TILE_SIZE, TILE_SIZE - 6);
                            
                            // Wave effect in the gap
                            ctx.fillStyle = "rgba(255,255,255,0.4)";
                            let wave = Math.sin((x + gameTime * 0.1)) * 3;
                            ctx.fillRect(px, py + 4 + wave, TILE_SIZE, 2);
                        } else {
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            // Internal glimmer
                             if ((x+y+Math.floor(gameTime/20)) % 7 === 0) {
                                ctx.fillStyle = "rgba(255,255,255,0.2)";
                                ctx.fillRect(px + 10, py + 10, 4, 4);
                             }
                        }
                    } else if (type === BLOCKS.LAVA) {
                        ctx.fillStyle = def.color;
                        ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                        // Bubbles
                        ctx.fillStyle = "#FFEB3B";
                        let bubbleY = (py + gameTime * 0.5 + x*10) % TILE_SIZE;
                        ctx.fillRect(px + (x*7)%20 + 5, py + TILE_SIZE - bubbleY, 4, 4);
                    } else if (type === BLOCKS.TNT) {
                        // Regular TNT
                        ctx.fillStyle = def.color;
                        ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                        // Label
                        ctx.fillStyle = "white";
                        ctx.font = "12px Arial";
                        ctx.textAlign = "center";
                        ctx.fillText("TNT", px + TILE_SIZE/2, py + TILE_SIZE/2 + 4);
                        ctx.strokeStyle = "rgba(0,0,0,0.2)";
                        ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE);
                    } else {
                        if (def.alpha) ctx.globalAlpha = def.alpha;
                        ctx.fillStyle = def.color;
                        
                        if (def.spike) {
                             ctx.beginPath();
                             ctx.moveTo(px, py + TILE_SIZE);
                             ctx.lineTo(px + TILE_SIZE/2, py);
                             ctx.lineTo(px + TILE_SIZE, py + TILE_SIZE);
                             ctx.fill();
                        } else if (type === BLOCKS.GOAL) {
                            ctx.fillStyle = '#1A237E'; 
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            ctx.fillStyle = '#000';
                            ctx.beginPath();
                            ctx.ellipse(px + TILE_SIZE/2, py + TILE_SIZE/2, 12, 16, 0, 0, Math.PI*2);
                            ctx.fill();
                            let pulse = Math.sin(gameTime * 0.1);
                            ctx.fillStyle = `rgba(0, 229, 255, ${0.6 + pulse * 0.2})`; 
                            ctx.beginPath();
                            ctx.ellipse(px + TILE_SIZE/2, py + TILE_SIZE/2, 8 + pulse, 12 - pulse, gameTime * 0.05, 0, Math.PI*2);
                            ctx.fill();
                        } else {
                            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                            if (def.top) { 
                                // Snowy grass check
                                ctx.fillStyle = (weather === "SNOW" && type === BLOCKS.GRASS) ? '#ffffff' : def.top; 
                                ctx.fillRect(px, py, TILE_SIZE, 8); 
                            }
                            if (def.speckle) { 
                                ctx.fillStyle = def.speckle; 
                                ctx.fillRect(px+10, py+10, 6, 6); 
                            }
                        }
                        ctx.globalAlpha = 1.0;
                    }
                }
            }
        }
        
        // Render Active TNTs
        activeTNTs.forEach(tnt => {
            let px = tnt.x * TILE_SIZE;
            let py = tnt.y * TILE_SIZE;
            
            // Flashing Effect
            if (Math.floor(gameTime / 5) % 2 === 0) {
                ctx.fillStyle = "#fff";
            } else {
                ctx.fillStyle = "#d32f2f";
            }
            ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
            
            ctx.fillStyle = "black";
            ctx.font = "12px Arial";
            ctx.textAlign = "center";
            ctx.fillText("TNT", px + TILE_SIZE/2, py + TILE_SIZE/2 + 4);
        });

        // Mobs
        mobs.forEach(m => {
            if (m.hurtTimer > 0) ctx.fillStyle = '#fff';
            else ctx.fillStyle = m.color;
            ctx.fillRect(m.x, m.y, m.width, m.height);
            // Health Bar
            ctx.fillStyle = 'red';
            ctx.fillRect(m.x, m.y - 10, m.width, 4);
            ctx.fillStyle = '#0f0';
            ctx.fillRect(m.x, m.y - 10, m.width * (m.hp / m.maxHp), 4);
            
            // Face
            ctx.fillStyle = 'black';
            if (m.type === 'bat') {
                 // Wings
                 ctx.beginPath();
                 ctx.moveTo(m.x, m.y+10);
                 ctx.lineTo(m.x-10, m.y-5);
                 ctx.lineTo(m.x, m.y+5);
                 ctx.fill();
                 ctx.beginPath();
                 ctx.moveTo(m.x+m.width, m.y+10);
                 ctx.lineTo(m.x+m.width+10, m.y-5);
                 ctx.lineTo(m.x+m.width, m.y+5);
                 ctx.fill();
            } else if (m.type === 'boss') {
                 ctx.fillRect(m.x + 10, m.y + 20, 15, 15);
                 ctx.fillRect(m.x + m.width - 25, m.y + 20, 15, 15);
                 ctx.fillRect(m.x + 20, m.y + 50, m.width - 40, 10);
            } else {
                 ctx.fillRect(m.x + 5, m.y + 8, 4, 4);
                 ctx.fillRect(m.x + m.width - 9, m.y + 8, 4, 4);
            }
        });

        // Projectiles
        projectiles.forEach(p => {
            ctx.fillStyle = '#FF5722';
            ctx.beginPath();
            ctx.arc(p.x, p.y, 6, 0, Math.PI*2);
            ctx.fill();
        });

        // Player
        ctx.fillStyle = '#FFC107'; 
        ctx.fillRect(player.x, player.y, player.width, player.height);
        ctx.fillStyle = '#1E88E5'; ctx.fillRect(player.x, player.y + 16, player.width, 12);
        ctx.fillStyle = '#43A047'; ctx.fillRect(player.x, player.y + 28, player.width, 10);
        
        ctx.fillStyle = 'black';
        let faceOffset = player.facingRight ? 4 : -4;
        ctx.fillRect(player.x + 14 + faceOffset - 6, player.y + 8, 4, 4); 
        ctx.fillRect(player.x + 14 + faceOffset + 2, player.y + 8, 4, 4);

        // Sword / Wand
        let currentItem = inventory[selectedBlockIndex];
        if (currentItem === ITEMS.SWORD || currentItem === ITEMS.WAND) {
            ctx.save();
            ctx.translate(player.x + player.width/2, player.y + 20);
            if (!player.facingRight) ctx.scale(-1, 1);
            let rot = 0;
            if (player.attackTimer > 0) rot = -Math.PI / 3 + (player.attackTimer / 15) * Math.PI;
            
            if (currentItem === ITEMS.WAND) {
                 rot = -Math.PI / 4; // Static hold
                 if (mouse.leftDown) rot = -Math.PI / 6;
            }

            ctx.rotate(rot);
            let def = BLOCK_DEF[currentItem];
            ctx.fillStyle = def.color; 
            ctx.fillRect(10, -4, 20, 6); 
            ctx.fillStyle = '#5d4037'; ctx.fillRect(0, -2, 10, 4); 
            ctx.restore();
        }

        // Particles
        particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, p.size, p.size);
        });
        
        // Interaction Range Ring (Subtle)
        if (gameState === "PLAY") {
            ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
            ctx.beginPath();
            ctx.arc(player.x + player.width/2, player.y + player.height/2, INTERACTION_RANGE, 0, Math.PI*2);
            ctx.stroke();
        }
        
        for (let i = floatTexts.length - 1; i >= 0; i--) {
            let ft = floatTexts[i];
            ctx.fillStyle = ft.color;
            ctx.font = "bold 16px Arial";
            ctx.fillText(ft.text, ft.x, ft.y);
            ft.y += ft.vy;
            ft.life--;
            if (ft.life <= 0) floatTexts.splice(i, 1);
        }

        // Selection Box
        let mx = mouse.x + camera.x;
        let my = mouse.y + camera.y;
        let sx = Math.floor(mx / TILE_SIZE) * TILE_SIZE;
        let sy = Math.floor(my / TILE_SIZE) * TILE_SIZE;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = 2;
        ctx.strokeRect(sx, sy, TILE_SIZE, TILE_SIZE);

        ctx.restore();

        // Weather Overlay (Static relative to screen)
        if (weather !== "NONE") {
            ctx.fillStyle = weather === "RAIN" ? "#64B5F6" : "#FFF";
            weatherParticles.forEach(p => {
                // Wrap horizontal
                if (p.x > width) p.x = 0;
                if (p.x < 0) p.x = width;
                
                if (p.type === 'rain') {
                    ctx.fillRect(p.x, p.y, 2, 10);
                } else {
                    ctx.fillRect(p.x, p.y, 4, 4);
                }
            });
        }

        // Damage Flash Overlay
        if (damageFlash > 0) {
            ctx.fillStyle = `rgba(255, 0, 0, ${damageFlash})`;
            ctx.fillRect(0, 0, width, height);
            damageFlash -= 0.02; // Fade out
        }
    }

    init();

</script>
</body>
</html>
