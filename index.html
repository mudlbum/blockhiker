<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Voxel Quest: Original Mobile</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: 'Segoe UI', sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* ëª¨ë°”ì¼ ì œìŠ¤ì²˜ ì°¨ë‹¨ */
        }
        canvas { display: block; touch-action: none; }

        /* UI ë ˆì´ì–´ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
        }

        /* HUD */
        #hud {
            position: absolute; top: 10px; left: 10px;
            color: white; font-weight: bold; font-size: 14px;
            text-shadow: 1px 1px 0 #000;
            display: flex; flex-direction: column; gap: 4px;
            pointer-events: none;
        }
        .stat-box { background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 4px; border: 1px solid #555; }
        .hp-bar-bg { width: 120px; height: 10px; background: #330000; border: 1px solid #fff; margin-top:2px; }
        .hp-bar-fill { width: 100%; height: 100%; background: #ff5252; transition: width 0.1s; }
        .breath-bg { display:none; border-color:#00B0FF; margin-top:2px; }
        .breath-fill { width:100%; height:6px; background:#00B0FF; }

        /* ë³´ìŠ¤ ì²´ë ¥ë°” */
        #boss-hud {
            position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
            width: 60%; max-width: 300px; display: none; text-align: center;
        }
        .boss-name { color: #FF4081; font-weight: bold; text-shadow: 1px 1px 0 #000; margin-bottom: 2px; }
        .boss-bar-bg { width: 100%; height: 12px; background: #222; border: 2px solid white; }
        .boss-bar-fill { width: 100%; height: 100%; background: #FF4081; transition: width 0.2s; }

        /* ì¸ë²¤í† ë¦¬ (ê°€ë¡œ ìŠ¤í¬ë¡¤) */
        #inventory-bar {
            position: absolute; top: 10px; right: 10px;
            display: flex; gap: 5px;
            width: 180px; overflow-x: auto;
            background: rgba(0,0,0,0.6); padding: 5px; border-radius: 8px;
            pointer-events: auto; white-space: nowrap;
            -webkit-overflow-scrolling: touch;
        }
        #inventory-bar::-webkit-scrollbar { display: none; }
        .slot {
            flex: 0 0 40px; width: 40px; height: 40px;
            background: rgba(255,255,255,0.1); border: 2px solid #555;
            display: flex; justify-content: center; align-items: center;
            border-radius: 6px; position: relative;
        }
        .slot.active { border-color: #FFD700; background: rgba(255,215,0,0.2); transform: scale(1.05); }
        .slot-icon { font-size: 20px; }
        .slot-block { width: 20px; height: 20px; box-shadow: 1px 1px 2px #000; }

        /* ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ëŸ¬ */
        #controls {
            position: absolute; bottom: 10px; width: 100%; height: 150px;
            pointer-events: none; display: flex; justify-content: space-between;
            padding: 0 20px; box-sizing: border-box;
        }
        .btn-group { display: flex; gap: 15px; align-items: flex-end; pointer-events: auto; }
        .touch-btn {
            width: 70px; height: 70px;
            background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            color: white; font-size: 24px; font-weight: bold;
            backdrop-filter: blur(2px);
            user-select: none;
        }
        .touch-btn:active { background: rgba(255,215,0,0.3); border-color: #FFD700; }
        
        /* ëª¨ë“œ ì „í™˜ ë²„íŠ¼ (ì±„êµ´/ê±´ì„¤) */
        #mode-toggle {
            position: absolute; bottom: 100px; right: 20px;
            width: 60px; height: 60px; border-radius: 12px;
            background: rgba(0,0,0,0.6); font-size: 24px;
            pointer-events: auto; border: 2px solid #fff;
            display: flex; justify-content: center; align-items: center;
        }
        .mode-mine { border-color: #ff5252 !important; color: #ff5252; }
        .mode-build { border-color: #40c4ff !important; color: #40c4ff; }

        /* ì˜¤ë²„ë ˆì´ (ìƒì  ë“±) */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100; pointer-events: auto;
        }
        .panel {
            background: #333; padding: 20px; border-radius: 15px;
            border: 3px solid #4CAF50; text-align: center; width: 85%; max-width: 350px;
            max-height: 90vh; overflow-y: auto; color: white;
        }
        .shop-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; }
        .shop-btn {
            background: #555; border: 1px solid #777; color: white;
            padding: 10px; border-radius: 8px; font-size: 13px;
        }
        .shop-btn:active { background: #777; }
        .big-btn {
            width: 100%; padding: 15px; font-size: 18px; font-weight: bold;
            background: #4CAF50; color: white; border: none; border-radius: 8px; margin-top: 10px;
        }

        .toast {
            position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%);
            color: #FFD700; font-size: 20px; font-weight: bold; text-shadow: 0 2px 4px #000;
            opacity: 0; transition: opacity 0.5s; pointer-events: none;
        }
        .sound-toggle {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            color: #aaa; font-size: 12px; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 15px; pointer-events: auto;
        }
    </style>
</head>
<body>

    <!-- ê²Œì„ ìº”ë²„ìŠ¤ -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI ë ˆì´ì–´ -->
    <div id="ui-layer">
        <div id="hud">
            <div class="stat-box">LV: <span id="ui-level">1</span> <span style="color:#FFD700; margin-left:10px;">$<span id="ui-gold">0</span></span></div>
            <div class="stat-box">
                <div style="display:flex; justify-content:space-between; font-size:12px; color:#ff5252;">
                    <span>HP</span> <span><span id="ui-hp">100</span>/<span id="ui-max">100</span></span>
                </div>
                <div class="hp-bar-bg"><div id="hp-bar" class="hp-bar-fill"></div></div>
                <div id="breath-box" class="hp-bar-bg breath-bg"><div id="breath-bar" class="breath-fill"></div></div>
            </div>
        </div>

        <div id="boss-hud">
            <div class="boss-name">BOSS</div>
            <div class="boss-bar-bg"><div id="boss-fill" class="boss-bar-fill"></div></div>
        </div>

        <div id="toast" class="toast">ì €ì¥ë¨!</div>
    </div>

    <!-- ì¸ë²¤í† ë¦¬ -->
    <div id="inventory-bar"></div>

    <!-- ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ -->
    <div id="controls">
        <div class="btn-group">
            <div id="btn-left" class="touch-btn">â—€</div>
            <div id="btn-right" class="touch-btn">â–¶</div>
        </div>
        <div class="btn-group">
            <div id="btn-jump" class="touch-btn" style="background:rgba(0,255,0,0.15);">â¬†</div>
        </div>
    </div>
    
    <!-- ëª¨ë“œ ì „í™˜ (ì±„êµ´/ê±´ì„¤) -->
    <div id="mode-toggle" class="mode-mine">â›ï¸</div>

    <div class="sound-toggle" onclick="toggleSound()">ğŸ”Š ì†Œë¦¬ ì¼œì§</div>

    <!-- ì˜¤ë²„ë ˆì´ ë©”ë‰´ -->
    <div id="overlay">
        <!-- ì‹œì‘ í™”ë©´ -->
        <div id="start-menu" class="panel">
            <h1 style="color:#FFD700; margin-top:0;">VOXEL QUEST</h1>
            <p>ëª¨ë°”ì¼ ì˜¤ë¦¬ì§€ë„</p>
            <button class="big-btn" onclick="startGame(true)">ìƒˆ ê²Œì„ ì‹œì‘</button>
            <button id="btn-continue" class="big-btn" style="background:#2196F3; display:none;" onclick="loadGame()">ì´ì–´í•˜ê¸°</button>
        </div>

        <!-- ìƒì  í™”ë©´ -->
        <div id="shop-menu" class="panel" style="display:none;">
            <h2 style="color:#FFD700;">ë ˆë²¨ í´ë¦¬ì–´!</h2>
            <p>ë³´ìœ  ê³¨ë“œ: <span id="shop-gold">0</span></p>
            <div class="shop-grid">
                <div class="shop-btn" onclick="buyItem('heal')">â¤ï¸ íšŒë³µ (50G)</div>
                <div class="shop-btn" onclick="buyItem('damage')">âš”ï¸ ê³µê²©ë ¥ (200G)</div>
                <div class="shop-btn" onclick="buyItem('speed')">ğŸ‘Ÿ ì´ì† (150G)</div>
                <div class="shop-btn" onclick="buyItem('maxhp')">ğŸ›¡ï¸ ìµœëŒ€ì²´ë ¥ (300G)</div>
                <div class="shop-btn" onclick="buyItem('wand')" id="btn-wand">ğŸ”¥ íŒŒì´ì–´ì™„ë“œ (500G)</div>
            </div>
            <button class="big-btn" onclick="nextLevel()">ë‹¤ìŒ ë ˆë²¨ >></button>
        </div>

        <!-- ì‚¬ë§ í™”ë©´ -->
        <div id="death-menu" class="panel" style="display:none; border-color:#d32f2f;">
            <h1 style="color:#d32f2f;">ì‚¬ë§í–ˆìŠµë‹ˆë‹¤</h1>
            <p>ë ˆë²¨ <span id="death-level">1</span>ì—ì„œ ì‹¤íŒ¨</p>
            <button class="big-btn" style="background:#d32f2f;" onclick="restartGame()">ë‹¤ì‹œ ë„ì „</button>
        </div>
    </div>

<script>
    // --- ì˜¤ë””ì˜¤ ì‹œìŠ¤í…œ (ê°„ë‹¨í•œ ì‹ ë””ì‚¬ì´ì €) ---
    const AudioSys = {
        ctx: null, muted: false,
        init() {
            if(!this.ctx) this.ctx = new (window.AudioContext||window.webkitAudioContext)();
            if(this.ctx.state==='suspended') this.ctx.resume();
        },
        playTone(freq, type, dur, vol=0.1) {
            if(this.muted || !this.ctx) return;
            const o=this.ctx.createOscillator(), g=this.ctx.createGain();
            o.type=type; o.frequency.value=freq;
            g.gain.setValueAtTime(vol, this.ctx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime+dur);
            o.connect(g); g.connect(this.ctx.destination);
            o.start(); o.stop(this.ctx.currentTime+dur);
        },
        noise(dur) {
            if(this.muted || !this.ctx) return;
            const b=this.ctx.createBuffer(1,this.ctx.sampleRate*dur,this.ctx.sampleRate), d=b.getChannelData(0);
            for(let i=0;i<b.length;i++) d[i]=Math.random()*2-1;
            const s=this.ctx.createBufferSource(), g=this.ctx.createGain();
            s.buffer=b; g.gain.setValueAtTime(0.1,this.ctx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01,this.ctx.currentTime+dur);
            s.connect(g); g.connect(this.ctx.destination); s.start();
        }
    };
    function toggleSound(){ AudioSys.muted=!AudioSys.muted; document.querySelector('.sound-toggle').innerText=AudioSys.muted?"ğŸ”‡ ì†Œë¦¬ êº¼ì§":"ğŸ”Š ì†Œë¦¬ ì¼œì§"; }
    const SFX = {
        jump:()=>AudioSys.playTone(300,'square',0.1,0.05),
        coin:()=>AudioSys.playTone(1200,'sine',0.15,0.1),
        hit:()=>AudioSys.playTone(100,'sawtooth',0.1,0.1),
        place:()=>AudioSys.playTone(400,'sine',0.05,0.05),
        exp:()=>AudioSys.noise(0.4)
    };

    // --- ê¸°ì¡´ ê²Œì„ ìƒìˆ˜ ë° ë°ì´í„° ---
    const TILE_SIZE = 40;
    const GRAVITY = 0.5;
    const TERMINAL_VELOCITY = 15;
    const JUMP_FORCE = -11;
    const INTERACTION_RANGE = 5 * TILE_SIZE;

    const BLOCKS = {
        AIR: 0, DIRT: 1, GRASS: 2, STONE: 3, WOOD: 4, LEAVES: 5, BRICK: 6,
        SAND: 7, SNOW: 8, COAL_ORE: 9, GOLD_ORE: 10, DIAMOND_ORE: 11,
        TNT: 12, GLASS: 13, PLANK: 14, SPIKE: 15, GOAL: 99,
        WATER: 20, LAVA: 21
    };
    const ITEMS = { SWORD: 100, WAND: 101 };

    const BLOCK_DEF = {
        [BLOCKS.DIRT]: { color: '#5d4037' },
        [BLOCKS.GRASS]: { color: '#5d4037', top: '#4caf50' },
        [BLOCKS.STONE]: { color: '#757575' },
        [BLOCKS.WOOD]: { color: '#5d4037', side: '#4e342e' },
        [BLOCKS.LEAVES]: { color: '#2e7d32', alpha: 0.9 },
        [BLOCKS.BRICK]: { color: '#b71c1c' },
        [BLOCKS.SAND]: { color: '#fbc02d' },
        [BLOCKS.SNOW]: { color: '#e0f7fa', top: '#ffffff' },
        [BLOCKS.COAL_ORE]: { color: '#757575', speckle: '#212121', value: 5 },
        [BLOCKS.GOLD_ORE]: { color: '#757575', speckle: '#ffeb3b', value: 15 },
        [BLOCKS.DIAMOND_ORE]: { color: '#757575', speckle: '#00bcd4', value: 50 },
        [BLOCKS.TNT]: { color: '#d32f2f', label: 'TNT' },
        [BLOCKS.GLASS]: { color: '#81d4fa', alpha: 0.4 },
        [BLOCKS.PLANK]: { color: '#8d6e63' },
        [BLOCKS.SPIKE]: { color: '#9E9E9E', spike: true },
        [BLOCKS.WATER]: { color: '#29B6F6', alpha: 0.5, fluid: true },
        [BLOCKS.LAVA]: { color: '#FF5722', alpha: 0.8, fluid: true, light: true },
        [BLOCKS.GOAL]: { color: '#6a1b9a', speckle: '#FFD700' }, 
        [ITEMS.SWORD]: { icon: 'ğŸ—¡ï¸', type: 'tool', color: '#00bcd4' },
        [ITEMS.WAND]: { icon: 'ğŸ”¥', type: 'tool', color: '#FF5722' }
    };

    // --- ì „ì—­ ë³€ìˆ˜ ---
    let canvas, ctx, width, height;
    let gameState = "MENU";
    let currentLevel = 1;
    let worldWidth = 100, worldHeight = 50;
    
    let world = [], particles = [], mobs = [], projectiles = [], activeTNTs = [];
    let weather = "NONE", weatherParticles = [];
    let gameTime = 0, shake = 0, damageFlash = 0;
    let activeBoss = null;

    let player = {
        x: 0, y: 0, width: 28, height: 38, vx: 0, vy: 0,
        grounded: false, facingRight: true, attackTimer: 0, actionTimer: 0,
        hp: 100, maxHp: 100, gold: 0, speed: 6, damage: 15,
        hasWand: false, breath: 100, inWater: false, invulnerable: 0
    };
    
    let camera = { x: 0, y: 0 };
    let inventory = [ITEMS.SWORD, BLOCKS.DIRT, BLOCKS.STONE, BLOCKS.WOOD, BLOCKS.TNT, BLOCKS.WATER];
    let selectedSlot = 0;

    // ëª¨ë°”ì¼ ì…ë ¥ ë³€ìˆ˜
    let keys = { ArrowLeft: false, ArrowRight: false, Space: false, KeyW: false };
    let touchMode = "MINE"; // MINE (ì¢Œí´ë¦­/íŒŒê´´) vs BUILD (ìš°í´ë¦­/ì„¤ì¹˜)

    // --- ì´ˆê¸°í™” ---
    window.onload = function() {
        canvas = document.getElementById('gameCanvas');
        ctx = canvas.getContext('2d', { alpha: false });
        resize();
        window.addEventListener('resize', resize);
        
        // ìë™ ì €ì¥ ë°ì´í„° í™•ì¸
        if(localStorage.getItem('vq_orig_save')) {
            document.getElementById('btn-continue').style.display = 'block';
        }

        setupControls();
        requestAnimationFrame(loop);
    };

    function resize() { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; }

    // --- ì…ë ¥ ì²˜ë¦¬ (ëª¨ë°”ì¼) ---
    function setupControls() {
        const bindBtn = (id, key) => {
            const el = document.getElementById(id);
            el.addEventListener('touchstart', (e) => { e.preventDefault(); el.style.background='rgba(255,215,0,0.4)'; keys[key] = true; });
            el.addEventListener('touchend', (e) => { e.preventDefault(); el.style.background=''; keys[key] = false; });
        };
        bindBtn('btn-left', 'ArrowLeft');
        bindBtn('btn-right', 'ArrowRight');
        bindBtn('btn-jump', 'Space');

        // ëª¨ë“œ ì „í™˜ ë²„íŠ¼
        const modeBtn = document.getElementById('mode-toggle');
        modeBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchMode = touchMode === "MINE" ? "BUILD" : "MINE";
            modeBtn.innerText = touchMode === "MINE" ? "â›ï¸" : "ğŸ§±";
            modeBtn.className = touchMode === "MINE" ? "mode-mine" : "mode-build";
        });

        // ìº”ë²„ìŠ¤ í„°ì¹˜ (ìƒí˜¸ì‘ìš©)
        canvas.addEventListener('touchstart', handleTouch, {passive: false});
        canvas.addEventListener('touchmove', handleTouch, {passive: false});
    }

    function handleTouch(e) {
        if(gameState !== "PLAY") return;
        e.preventDefault();
        const t = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        
        // í„°ì¹˜ ì¢Œí‘œë¥¼ ì›”ë“œ ì¢Œí‘œë¡œ ë³€í™˜í•˜ì§€ ì•Šê³  handleInteractionì— ì „ë‹¬í•˜ê¸° ìœ„í•´
        // ë§ˆìš°ìŠ¤ ì—ë®¬ë ˆì´ì…˜ ê°ì²´ë¥¼ ìƒì„±í•˜ì—¬ ì „ë‹¬
        const mx = t.clientX - rect.left;
        const my = t.clientY - rect.top;

        // ì•„ì´í…œ ì‚¬ìš© (ì¹¼/ì™„ë“œ)ì€ í„°ì¹˜ ì¦‰ì‹œ ë°œë™
        let item = inventory[selectedSlot];
        if(item === ITEMS.SWORD || item === ITEMS.WAND) {
            handleInteraction(0, mx, my); // ê³µê²©ì€ í•­ìƒ ì¢Œí´ë¦­ íŒì •
        } else {
            // ë¸”ë¡ ì„¤ì¹˜/íŒŒê´´ëŠ” ëª¨ë“œì— ë”°ë¼ ë‹¤ë¦„
            // MINE ëª¨ë“œ = ì¢Œí´ë¦­(0), BUILD ëª¨ë“œ = ìš°í´ë¦­(2)
            handleInteraction(touchMode === "MINE" ? 0 : 2, mx, my);
        }
    }

    // --- ê²Œì„ ì‹œì‘ ë° ë¡œë“œ ---
    function startGame(reset) {
        AudioSys.init();
        if(reset) {
            currentLevel = 1;
            player = {
                x: 0, y: 0, width: 28, height: 38, vx: 0, vy: 0,
                grounded: false, facingRight: true, attackTimer: 0, actionTimer: 0,
                hp: 100, maxHp: 100, gold: 0, speed: 6, damage: 15,
                hasWand: false, breath: 100, inWater: false, invulnerable: 0
            };
            inventory = [ITEMS.SWORD, BLOCKS.DIRT, BLOCKS.STONE, BLOCKS.WOOD, BLOCKS.TNT, BLOCKS.WATER];
        }
        generateLevel(currentLevel);
        gameState = "PLAY";
        document.getElementById('overlay').style.display = 'none';
        updateInventoryUI();
        updateHUD();
    }

    function loadGame() {
        try {
            const data = JSON.parse(localStorage.getItem('vq_orig_save'));
            currentLevel = data.lvl;
            player.hp = data.hp; player.maxHp = data.maxHp; player.gold = data.gold;
            player.speed = data.spd; player.damage = data.dmg; player.hasWand = data.wand;
            inventory = data.inv;
            startGame(false);
            showToast("ë¡œë“œ ì™„ë£Œ!");
        } catch(e) {
            alert("ì €ì¥ëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.");
            startGame(true);
        }
    }

    // --- ë ˆë²¨ ìƒì„± (ì˜¤ë¦¬ì§€ë„ ë¡œì§) ---
    function generateLevel(level) {
        world = []; particles = []; mobs = []; projectiles = []; activeTNTs = []; weatherParticles = [];
        activeBoss = null; document.getElementById('boss-hud').style.display = 'none';

        let wRand = Math.random();
        if (wRand < 0.2) weather = "RAIN";
        else if (wRand < 0.4 && level > 2) weather = "SNOW";
        else weather = "NONE";

        worldWidth = 150 + (level * 20);
        worldHeight = 60;
        
        // ì§€í˜• ë†’ì´ ë…¸ì´ì¦ˆ
        const heights = [];
        for (let x = 0; x < worldWidth; x++) {
            let base = Math.sin(x * 0.05) * (5 + level * 2); 
            let detail = Math.sin(x * 0.3) * (2 + level);
            let h = Math.floor(worldHeight / 2 + base + detail);
            if(h < 5) h = 5; if(h > worldHeight - 5) h = worldHeight - 5;
            heights.push(h);
        }

        const isBossLevel = level % 3 === 0;

        for (let y = 0; y < worldHeight; y++) {
            let row = [];
            for (let x = 0; x < worldWidth; x++) {
                let h = heights[x];
                let block = BLOCKS.AIR;

                if (x < 20) { // ì‹œì‘ ì§€ì  í‰íƒ„í™”
                    h = Math.floor(worldHeight / 2);
                    if (y >= h) block = (y === h) ? BLOCKS.GRASS : BLOCKS.DIRT;
                    if (y >= worldHeight - 2) block = BLOCKS.BRICK;
                } else {
                    let isGap = false;
                    if (!isBossLevel && x < worldWidth - 20) {
                        if (Math.sin(x*0.8) * Math.cos(x*0.4) > 0.9 - (level*0.02)) isGap = true;
                    }

                    if (isGap && y > worldHeight - 5) block = (Math.random() < 0.5) ? BLOCKS.SPIKE : BLOCKS.LAVA;
                    else if (!isGap && y >= h) {
                        if (y === h) block = BLOCKS.GRASS;
                        else if (y > h && y <= h + 4) block = BLOCKS.DIRT; 
                        else {
                            block = BLOCKS.STONE;
                            let r = Math.random();
                            if (r < 0.05) block = BLOCKS.COAL_ORE;
                            else if (r < 0.03) block = BLOCKS.GOLD_ORE;
                            else if (r < 0.02) block = BLOCKS.DIAMOND_ORE;
                        }
                    }
                    if (y >= worldHeight - 2) block = BLOCKS.BRICK;
                }
                
                if (x === worldWidth - 4 && y === h - 1) block = BLOCKS.GOAL;
                row.push(block);
            }
            world.push(row);
        }

        // ì—°ëª» ìƒì„± (ì˜¤ë¦¬ì§€ë„ ì•Œê³ ë¦¬ì¦˜ ë³µêµ¬)
        let numPonds = Math.floor(Math.random() * 4);
        for(let i=0; i<numPonds; i++) {
            let pW = 7 + Math.floor(Math.random() * 6);
            let startX = 25 + Math.floor(Math.random() * (worldWidth - 50));
            let centerIdx = startX + Math.floor(pW/2);
            if (centerIdx >= heights.length) continue;
            let surfaceY = heights[centerIdx];
            
            for (let x = startX; x < startX + pW; x++) {
                if(x >= worldWidth-10) continue;
                let xDist = (x - (startX + pW/2));
                let maxY = Math.floor(surfaceY + (3 + Math.random()*3) * Math.sqrt(1 - (xDist*xDist)/((pW/2)*(pW/2))));
                for (let y = surfaceY; y <= maxY; y++) {
                    if (y>=0 && y<worldHeight-2 && world[y] && world[y][x] !== BLOCKS.AIR && world[y][x] !== BLOCKS.GOAL) {
                        world[y][x] = BLOCKS.WATER;
                    }
                }
            }
        }

        // ëª¬ìŠ¤í„° ìŠ¤í°
        const mobChance = Math.min(0.05, 0.02 + (level * 0.005));
        for (let x = 20; x < worldWidth - 20; x++) {
            if (isBossLevel && x > worldWidth - 60) continue;
            if (Math.random() < mobChance) {
                let h = heights[x];
                if (world[h][x] !== BLOCKS.AIR && world[h-1][x] === BLOCKS.AIR) {
                    spawnMob(x * TILE_SIZE, (h - 2) * TILE_SIZE, (Math.random()<0.6)?'SLIME':'ZOMBIE');
                }
                if (level > 2 && Math.random() < 0.3) spawnMob(x * TILE_SIZE, (h - 10) * TILE_SIZE, 'BAT');
            }
        }

        if (isBossLevel) {
            let bx = (worldWidth - 30) * TILE_SIZE;
            let bossType = 'BOSS_SLIME';
            if (level % 9 === 0) bossType = 'BOSS_VOID';
            else if (level % 6 === 0) bossType = 'BOSS_ZOMBIE';
            spawnMob(bx, 0, bossType);
        }

        player.x = 5 * TILE_SIZE;
        player.y = (Math.floor(worldHeight/2) - 5) * TILE_SIZE; // ì•ˆì „í•˜ê²Œ ê³µì¤‘ ìŠ¤í°
        player.vx=0; player.vy=0;
        
        camera.x = player.x + player.width/2 - width/2;
        camera.y = player.y + player.height/2 - height/2;

        updateHUD();
    }

    const MOB_TYPES = {
        SLIME: { color: '#76ff03', width: 30, height: 20, speed: 2, jump: -8, hp: 30, reward: 10, type: 'slime' },
        ZOMBIE: { color: '#2e7d32', width: 28, height: 38, speed: 1.5, jump: -10, hp: 50, reward: 20, type: 'zombie' },
        BAT: { color: '#424242', width: 20, height: 20, speed: 3, jump: 0, hp: 20, reward: 15, type: 'bat', fly: true },
        BOSS_SLIME: { color: '#00E676', width: 90, height: 90, speed: 3, jump: -14, hp: 600, reward: 500, type: 'boss', name: "KING SLIME" },
        BOSS_ZOMBIE: { color: '#D50000', width: 60, height: 100, speed: 4, jump: -12, hp: 800, reward: 600, type: 'boss', name: "MUTANT ZOMBIE" },
        BOSS_VOID: { color: '#212121', width: 100, height: 120, speed: 2, jump: -10, hp: 1200, reward: 1000, type: 'boss', name: "VOID LORD" }
    };

    function spawnMob(x, y, typeKey) {
        let stats = MOB_TYPES[typeKey];
        let hpScale = stats.hp + (currentLevel * 10);
        let m = { x: x, y: y, vx: 0, vy: 0, ...stats, maxHp: hpScale, hp: hpScale, grounded: false, hurtTimer: 0 };
        mobs.push(m);
        if (stats.type === 'boss') {
            activeBoss = m;
        }
    }

    // --- ë©”ì¸ ë£¨í”„ ---
    function loop() {
        if (gameState === "PLAY") update();
        draw();
        requestAnimationFrame(loop);
    }

    function update() {
        gameTime++;
        if(shake > 0) shake *= 0.9;
        if(damageFlash > 0) damageFlash -= 0.05;
        if(player.invulnerable > 0) player.invulnerable--;

        // ë‚ ì”¨ íŒŒí‹°í´
        if (weather === "RAIN" && Math.random() < 0.5) weatherParticles.push({x: Math.random()*width, y: -10, vy: 15+Math.random()*5, type: 'rain'});
        else if (weather === "SNOW" && Math.random() < 0.2) weatherParticles.push({x: Math.random()*width, y: -10, vy: 2+Math.random(), vx: Math.random()-0.5, type: 'snow'});

        // ë¬¼ë¦¬ ê³„ì‚°ìš©
        let blockAtFeet = getBlock(Math.floor((player.x + player.width/2)/TILE_SIZE), Math.floor((player.y + player.height/2)/TILE_SIZE));
        player.inWater = (blockAtFeet === BLOCKS.WATER);
        let inLava = (blockAtFeet === BLOCKS.LAVA);

        // ì´ë™ ë¡œì§
        let moveSpeed = player.speed;
        if (player.inWater) moveSpeed *= 0.5;
        if (inLava) moveSpeed *= 0.1;

        if (keys['ArrowLeft']) { player.vx = -moveSpeed; player.facingRight = false; }
        else if (keys['ArrowRight']) { player.vx = moveSpeed; player.facingRight = true; }
        else player.vx = 0;

        if (keys['Space'] || keys['KeyW']) {
            if (player.inWater) {
                let headBlock = getBlock(Math.floor((player.x+player.width/2)/TILE_SIZE), Math.floor(player.y/TILE_SIZE)-1);
                if(headBlock === BLOCKS.AIR) player.vy = JUMP_FORCE * 0.5;
                else player.vy = -3;
                SFX.jump();
            } else if (player.grounded) {
                player.vy = JUMP_FORCE;
                player.grounded = false;
                SFX.jump();
            }
            keys['Space'] = false; // ì—°íƒ€ ë°©ì§€
        }

        // ì¤‘ë ¥
        if (player.inWater) {
            player.vy += 0.1; if(player.vy > 3) player.vy = 3;
            player.breath -= 0.5;
            if(player.breath <= 0 && gameTime % 30 === 0) takeDamage(5);
        } else {
            player.vy += GRAVITY;
            player.breath = Math.min(player.breath + 1, 100);
        }
        if (inLava && gameTime % 30 === 0) takeDamage(10);
        if (player.vy > TERMINAL_VELOCITY) player.vy = TERMINAL_VELOCITY;

        if (player.attackTimer > 0) player.attackTimer--;
        if (player.actionTimer > 0) player.actionTimer--;

        // ìœ„ì¹˜ ì ìš© ë° ì¶©ëŒ
        player.x += player.vx; checkEntityCollision(player, 'x');
        player.y += player.vy; player.grounded = false; checkEntityCollision(player, 'y');

        // ì‚¬ë§ ì²´í¬
        if (player.y > worldHeight * TILE_SIZE + 200) die();
        if (player.hp <= 0) die();

        // ê³¨ì¸ ì²´í¬
        let px = Math.floor((player.x + player.width/2) / TILE_SIZE);
        let py = Math.floor((player.y + player.height/2) / TILE_SIZE);
        if (getBlock(px, py) === BLOCKS.GOAL) completeLevel();

        // ì¹´ë©”ë¼ ì´ë™
        let targetCamX = player.x + player.width / 2 - width / 2;
        let targetCamY = player.y + player.height / 2 - height / 2;
        camera.x += (targetCamX - camera.x) * 0.1;
        camera.y += (targetCamY - camera.y) * 0.1;

        updateMobs();
        updateProjectiles();
        updateParticles();
        updateTNTs();
        updateHUD();
    }

    // --- ì—”í‹°í‹° ì—…ë°ì´íŠ¸ (ì˜¤ë¦¬ì§€ë„ ë¡œì§ ìœ ì§€) ---
    function updateMobs() {
        if(activeBoss) {
            let dist = Math.abs(player.x - activeBoss.x);
            let hud = document.getElementById('boss-hud');
            if(dist < 800 && activeBoss.hp > 0) {
                hud.style.display = 'block';
                document.getElementById('boss-fill').style.width = (activeBoss.hp/activeBoss.maxHp)*100+'%';
            } else hud.style.display = 'none';
        }

        for (let i = mobs.length - 1; i >= 0; i--) {
            let m = mobs[i];
            let dist = player.x - m.x;
            let mBlock = getBlock(Math.floor((m.x+m.width/2)/TILE_SIZE), Math.floor((m.y+m.height/2)/TILE_SIZE));

            if (Math.abs(dist) < 600) {
                if(m.type === 'bat') {
                    m.vx = (dist > 0 ? 1 : -1) * m.speed;
                    m.vy = (player.y - m.y > 0 ? 1 : -1) * 1.5;
                } else {
                    let speedMult = (mBlock === BLOCKS.WATER) ? 0.5 : 1;
                    if (dist > 10) m.vx = m.speed * speedMult;
                    else if (dist < -10) m.vx = -m.speed * speedMult;
                    if (m.vx !== 0 && isBlocked(m) && m.grounded) m.vy = m.jump;
                }

                if (checkRectOverlap(player, m) && gameTime % 20 === 0) {
                    takeDamage(m.type === 'boss' ? 20+currentLevel : 5+currentLevel);
                    player.vx = Math.sign(player.x - m.x) * 10; player.vy = -5;
                }
            } else { if(!m.fly) m.vx *= 0.9; }

            if(!m.fly) m.vy += GRAVITY;
            m.x += m.vx; checkEntityCollision(m, 'x');
            m.y += m.vy; m.grounded = false; checkEntityCollision(m, 'y');

            if(m.hurtTimer > 0) m.hurtTimer--;

            if(m.y > worldHeight * TILE_SIZE + 100) mobs.splice(i, 1);
            else if(m.hp <= 0) {
                spawnParticles(m.x/TILE_SIZE, m.y/TILE_SIZE, m.color, 15);
                player.gold += m.reward;
                SFX.coin();
                showToast(`+${m.reward}G`);
                if(m === activeBoss) { activeBoss = null; document.getElementById('boss-hud').style.display='none'; shake=20; }
                mobs.splice(i, 1);
            }
        }
    }

    function updateProjectiles() {
        for (let i = projectiles.length - 1; i >= 0; i--) {
            let p = projectiles[i];
            p.x += p.vx; p.y += p.vy; p.vy += 0.2; p.life--;
            let tx = Math.floor(p.x/TILE_SIZE), ty = Math.floor(p.y/TILE_SIZE);
            let b = getBlock(tx, ty);
            if((b !== BLOCKS.AIR && !BLOCK_DEF[b].fluid) || p.life <= 0) {
                explode(tx, ty, 2); projectiles.splice(i, 1); continue;
            }
            for(let m of mobs) {
                if(p.x > m.x && p.x < m.x+m.width && p.y > m.y && p.y < m.y+m.height) {
                    m.hp -= (30 + player.damage); m.hurtTimer = 10;
                    spawnParticles(m.x/TILE_SIZE, m.y/TILE_SIZE, '#FF5722', 10);
                    explode(tx, ty, 1.5); projectiles.splice(i, 1); break;
                }
            }
        }
    }

    function updateTNTs() {
        for(let i = activeTNTs.length - 1; i >= 0; i--) {
            let t = activeTNTs[i]; t.timer--;
            if(t.timer <= 0) { explode(t.x, t.y, 4); activeTNTs.splice(i, 1); }
        }
    }

    function updateParticles() {
        for(let i=particles.length-1; i>=0; i--) {
            let p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=0.2; p.life--;
            if(p.life<=0) particles.splice(i,1);
        }
        for(let i=weatherParticles.length-1; i>=0; i--) {
            let p=weatherParticles[i]; p.x += (p.vx||0) - player.vx; p.y += p.vy;
            if(p.y > height) weatherParticles.splice(i,1);
        }
    }

    // --- ìƒí˜¸ì‘ìš© ë° ë¬¼ë¦¬ í•¨ìˆ˜ ---
    function handleInteraction(button, mx, my) {
        if(player.actionTimer > 0) return;
        
        let worldX = mx + camera.x;
        let worldY = my + camera.y;
        let tx = Math.floor(worldX / TILE_SIZE);
        let ty = Math.floor(worldY / TILE_SIZE);

        let selected = inventory[selectedSlot];

        // ë„êµ¬ ì‚¬ìš© (ì¹¼/ì§€íŒ¡ì´) - í™”ë©´ ì–´ë””ë“  í„°ì¹˜ ì‹œ ë°œë™
        if (button === 0 && (selected === ITEMS.SWORD || selected === ITEMS.WAND)) {
            if(player.attackTimer <= 0) {
                if(selected === ITEMS.SWORD) {
                    performAttack();
                    SFX.place();
                } else {
                    shootWand(worldX, worldY);
                    SFX.place();
                }
                player.actionTimer = 10;
            }
            return;
        }

        // ê±°ë¦¬ ì œí•œ (ì±„êµ´/ê±´ì„¤)
        let dist = Math.hypot(player.x + player.width/2 - worldX, player.y + player.height/2 - worldY);
        if (dist > INTERACTION_RANGE) return;
        
        player.actionTimer = 8;

        if (button === 0) { // Mine (ì¢Œí´ë¦­/ì±„êµ´ ëª¨ë“œ)
            let current = getBlock(tx, ty);
            if (current === BLOCKS.TNT) {
                setBlock(tx, ty, BLOCKS.AIR); activeTNTs.push({x:tx, y:ty, timer:100}); SFX.place();
            } else if (current !== BLOCKS.AIR && current !== BLOCKS.GOAL) {
                if (player.gold >= 1) {
                    player.gold--;
                    let def = BLOCK_DEF[current];
                    if(def.value) { player.gold += def.value; SFX.coin(); showToast(`+${def.value}G`); }
                    else SFX.place();
                    spawnParticles(tx, ty, def.color, 5);
                    setBlock(tx, ty, BLOCKS.AIR);
                } else showToast("ê³¨ë“œ ë¶€ì¡±!");
            }
        } else if (button === 2) { // Place (ìš°í´ë¦­/ê±´ì„¤ ëª¨ë“œ)
            // í”Œë ˆì´ì–´ì™€ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸
            let px = player.x/TILE_SIZE, py = player.y/TILE_SIZE;
            if (!(tx >= px + player.width/TILE_SIZE || tx+1 <= px || ty >= py + player.height/TILE_SIZE || ty+1 <= py)) return;
            
            let current = getBlock(tx, ty);
            if (current === BLOCKS.AIR || BLOCK_DEF[current].fluid) {
                let cost = (selected===BLOCKS.WATER?5:(selected===BLOCKS.LAVA?30:1));
                if (player.gold >= cost) {
                    player.gold -= cost; setBlock(tx, ty, selected); SFX.place();
                } else showToast("ê³¨ë“œ ë¶€ì¡±!");
            }
        }
    }

    function performAttack() {
        player.attackTimer = 15;
        let reach = 80;
        let hitX = player.facingRight ? player.x + player.width/2 - 10 : player.x + player.width/2 - reach + 10;
        let hitRect = {x: hitX, y: player.y - 10, width: reach, height: player.height + 20};
        
        mobs.forEach(m => {
            if(checkRectOverlap(hitRect, m)) {
                m.hp -= player.damage; m.hurtTimer = 10; m.vy = -5;
                m.vx = player.facingRight ? 8 : -8;
                spawnParticles(m.x/TILE_SIZE, m.y/TILE_SIZE, '#fff', 5);
                SFX.hit(); shake = 2;
            }
        });
    }

    function shootWand(mx, my) {
        let angle = Math.atan2(my - (player.y+20), mx - (player.x+14));
        projectiles.push({x:player.x+14, y:player.y+20, vx:Math.cos(angle)*10, vy:Math.sin(angle)*10, life:60});
    }

    function explode(cx, cy, radius) {
        SFX.exp(); shake = radius*3;
        spawnParticles(cx, cy, '#f00', 30);
        let r = Math.ceil(radius);
        for(let y=cy-r; y<=cy+r; y++) for(let x=cx-r; x<=cx+r; x++) {
            if((x-cx)**2 + (y-cy)**2 <= radius**2) {
                if(getBlock(x,y)!==BLOCKS.GOAL && getBlock(x,y)!==BLOCKS.BRICK) setBlock(x,y,BLOCKS.AIR);
            }
        }
        mobs.forEach(m=>{
            if(Math.hypot(m.x/TILE_SIZE-cx, m.y/TILE_SIZE-cy) < radius) { m.hp-=50; m.vy=-10; }
        });
    }

    // --- ìœ í‹¸ë¦¬í‹° ---
    function getBlock(x, y) { if(x>=0 && x<worldWidth && y>=0 && y<worldHeight) return world[y][x]; return BLOCKS.AIR; }
    function setBlock(x, y, id) { if(x>=0 && x<worldWidth && y>=0 && y<worldHeight) world[y][x] = id; }
    function checkRectOverlap(a, b) { return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y; }
    function checkEntityCollision(ent, axis) {
        let left = Math.floor(ent.x/TILE_SIZE), right = Math.floor((ent.x+ent.width-0.01)/TILE_SIZE);
        let top = Math.floor(ent.y/TILE_SIZE), bottom = Math.floor((ent.y+ent.height-0.01)/TILE_SIZE);
        for(let y=top; y<=bottom; y++) for(let x=left; x<=right; x++) {
            let b = getBlock(x, y); let def = BLOCK_DEF[b];
            if(b===BLOCKS.AIR || (def && def.fluid)) continue;
            if(b===BLOCKS.SPIKE && ent===player) { takeDamage(10); ent.vy=-10; }
            if(b!==BLOCKS.GOAL && b!==BLOCKS.SPIKE && (!def || !def.alpha)) {
                if(axis==='x') { ent.x = ent.vx>0 ? x*TILE_SIZE-ent.width : (x+1)*TILE_SIZE; ent.vx=0; }
                else { if(ent.vy>0){ent.y=y*TILE_SIZE-ent.height; ent.grounded=true;} else ent.y=(y+1)*TILE_SIZE; ent.vy=0; }
                return;
            }
        }
    }
    function isBlocked(e) {
        let tx = Math.floor((e.x + (e.vx>0?e.width+5:-5))/TILE_SIZE);
        let ty = Math.floor((e.y+e.height-5)/TILE_SIZE);
        let b = getBlock(tx, ty); return b!==BLOCKS.AIR && !BLOCK_DEF[b].fluid;
    }
    function takeDamage(amt) {
        if(player.invulnerable>0)return;
        player.hp-=amt; player.invulnerable=20; damageFlash=0.6; shake=5; SFX.hit(); updateHUD();
    }
    function spawnParticles(tx, ty, c, n) {
        for(let i=0; i<n; i++) particles.push({x:tx*TILE_SIZE+20, y:ty*TILE_SIZE+20, vx:(Math.random()-.5)*10, vy:(Math.random()-.5)*10, life:30, color:c, size:Math.random()*5+2});
    }

    // --- UI ë° ì‹œìŠ¤í…œ ---
    function completeLevel() {
        if(gameState==="SHOP") return;
        gameState="SHOP"; player.gold+=100; SFX.coin();
        saveGame();
        document.getElementById('overlay').style.display='flex';
        document.getElementById('shop-menu').style.display='block';
        document.getElementById('shop-gold').innerText=player.gold;
    }
    function die() {
        gameState="DEAD";
        document.getElementById('overlay').style.display='flex';
        document.getElementById('shop-menu').style.display='none';
        document.getElementById('death-menu').style.display='block';
        document.getElementById('death-level').innerText=currentLevel;
    }
    function restartGame() { player.hp=player.maxHp; generateLevel(currentLevel); startGame(false); }
    window.nextLevel = function() { currentLevel++; generateLevel(currentLevel); gameState="PLAY"; document.getElementById('overlay').style.display='none'; }
    
    function saveGame() {
        const data = { lvl: currentLevel, hp: player.hp, maxHp: player.maxHp, gold: player.gold, spd: player.speed, dmg: player.damage, wand: player.hasWand, inv: inventory };
        localStorage.setItem('vq_orig_save', JSON.stringify(data));
        showToast("ìë™ ì €ì¥ë¨");
    }
    function showToast(msg) { let t=document.getElementById('toast'); t.innerText=msg; t.style.opacity=1; setTimeout(()=>t.style.opacity=0, 1500); }

    window.buyItem = function(t) {
        let cost=0;
        if(t==='heal'){cost=50;if(player.gold>=cost)player.hp=Math.min(player.hp+50,player.maxHp);}
        if(t==='damage'){cost=200;if(player.gold>=cost)player.damage+=10;}
        if(t==='speed'){cost=150;if(player.gold>=cost)player.speed++;}
        if(t==='maxhp'){cost=300;if(player.gold>=cost){player.maxHp+=50;player.hp+=50;}}
        if(t==='wand'){cost=500;if(player.gold>=cost&&!player.hasWand){player.hasWand=true;inventory.push(ITEMS.WAND);updateInventoryUI();}}
        if(player.gold>=cost){player.gold-=cost;SFX.coin();updateHUD();document.getElementById('shop-gold').innerText=player.gold;}
        else showToast("ê³¨ë“œ ë¶€ì¡±!");
    };

    function updateHUD() {
        document.getElementById('ui-level').innerText=currentLevel;
        document.getElementById('ui-gold').innerText=player.gold;
        document.getElementById('ui-hp').innerText=Math.floor(player.hp);
        document.getElementById('ui-max').innerText=player.maxHp;
        document.getElementById('hp-bar').style.width = Math.max(0, player.hp/player.maxHp*100)+'%';
        
        let bb = document.getElementById('breath-box');
        if(player.inWater) { bb.style.display='block'; document.getElementById('breath-bar').style.width=player.breath+'%'; }
        else bb.style.display='none';
    }

    function updateInventoryUI() {
        const bar = document.getElementById('inventory-bar'); bar.innerHTML = '';
        inventory.forEach((item, i) => {
            let el = document.createElement('div');
            el.className = 'slot' + (i===selectedSlot?' active':'');
            let def = BLOCK_DEF[item];
            if(def.type === 'tool') el.innerHTML = `<span class="slot-icon">${def.icon}</span>`;
            else el.innerHTML = `<div class="slot-block" style="background:${def.color};${def.top?`border-top:4px solid ${def.top}`:''}"></div>`;
            el.onclick = () => { selectedSlot = i; updateInventoryUI(); };
            bar.appendChild(el);
        });
    }

    // --- ê·¸ë¦¬ê¸° ---
    function draw() {
        let timeNorm = (Math.sin(gameTime * 0.001) + 1) / 2;
        let r, g, b;
        if (weather === "RAIN") { r = 50; g = 60; b = 80; } 
        else { r = Math.floor(135 * timeNorm); g = Math.floor(206 * timeNorm); b = Math.floor(235 * timeNorm); }
        ctx.fillStyle = `rgb(${Math.max(20,r)},${Math.max(20,g)},${Math.max(50,b)})`;
        ctx.fillRect(0, 0, width, height);

        // ë°°ê²½ ì‚° (íŒ¨ëŸ´ë™ìŠ¤)
        ctx.fillStyle = weather==="RAIN" ? `rgba(0,0,0,0.4)` : `rgba(0,0,0,0.2)`;
        ctx.beginPath(); ctx.moveTo(0, height);
        for(let i=0; i<=width; i+=10) ctx.lineTo(i, height - (150 + Math.sin((i+camera.x*0.1)*0.005)*50));
        ctx.lineTo(width, height); ctx.fill();

        ctx.save();
        let cx = Math.floor(camera.x), cy = Math.floor(camera.y);
        ctx.translate(-cx + (Math.random()-.5)*shake, -cy + (Math.random()-.5)*shake);

        let sc=Math.floor(cx/TILE_SIZE), ec=sc+Math.ceil(width/TILE_SIZE)+1;
        let sr=Math.floor(cy/TILE_SIZE), er=sr+Math.ceil(height/TILE_SIZE)+1;

        for(let y=Math.max(0,sr); y<Math.min(worldHeight,er); y++) {
            if(!world[y]) continue;
            for(let x=Math.max(0,sc); x<Math.min(worldWidth,ec); x++) {
                let type = world[y][x];
                if (type !== BLOCKS.AIR) {
                    let def = BLOCK_DEF[type];
                    let px = x * TILE_SIZE, py = y * TILE_SIZE;
                    if(def.alpha) ctx.globalAlpha = def.alpha;
                    ctx.fillStyle = def.color;

                    if (type === BLOCKS.WATER && (!world[y-1] || world[y-1][x]===BLOCKS.AIR)) {
                        ctx.fillRect(px, py+6, TILE_SIZE, TILE_SIZE-6);
                        ctx.fillStyle="rgba(255,255,255,0.4)"; ctx.fillRect(px,py+6,TILE_SIZE,3);
                    } else if(def.spike) {
                        ctx.beginPath();ctx.moveTo(px,py+TILE_SIZE);ctx.lineTo(px+TILE_SIZE/2,py);ctx.lineTo(px+TILE_SIZE,py+TILE_SIZE);ctx.fill();
                    } else {
                        ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                        if(def.top) { ctx.fillStyle=def.top; ctx.fillRect(px, py, TILE_SIZE, 8); }
                        if(def.speckle) { ctx.fillStyle=def.speckle; ctx.fillRect(px+10, py+10, 6, 6); }
                        if(def.label) { ctx.fillStyle='white'; ctx.font='10px arial'; ctx.fillText(def.label, px+8, py+24); }
                    }
                    ctx.globalAlpha = 1.0;
                }
            }
        }

        activeTNTs.forEach(t => {
            ctx.fillStyle = (Math.floor(gameTime/5)%2===0) ? "#fff" : "#d32f2f";
            ctx.fillRect(t.x*TILE_SIZE, t.y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
        });

        mobs.forEach(m => {
            ctx.fillStyle = m.hurtTimer > 0 ? '#fff' : m.color;
            ctx.fillRect(m.x, m.y, m.width, m.height);
            ctx.fillStyle = 'red'; ctx.fillRect(m.x, m.y-8, m.width, 4);
            ctx.fillStyle = '#0f0'; ctx.fillRect(m.x, m.y-8, m.width * (m.hp/m.maxHp), 4);
            if(m.type==='boss') {
                ctx.fillStyle='black'; ctx.fillRect(m.x+10, m.y+20, 10, 10); ctx.fillRect(m.x+m.width-20, m.y+20, 10, 10);
            }
        });

        projectiles.forEach(p => {
            ctx.fillStyle = '#FF5722'; ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI*2); ctx.fill();
        });

        ctx.fillStyle = '#FFC107'; ctx.fillRect(player.x, player.y, player.width, player.height);
        ctx.fillStyle = '#1E88E5'; ctx.fillRect(player.x, player.y + 16, player.width, 12);
        ctx.fillStyle = 'black';
        let faceOffset = player.facingRight ? 4 : -4;
        ctx.fillRect(player.x+14+faceOffset-6, player.y+8, 4, 4); ctx.fillRect(player.x+14+faceOffset+2, player.y+8, 4, 4);

        let item = inventory[selectedSlot];
        if (item === ITEMS.SWORD || item === ITEMS.WAND) {
            ctx.save(); ctx.translate(player.x + player.width/2, player.y + 20);
            if (!player.facingRight) ctx.scale(-1, 1);
            let rot = 0; if (player.attackTimer > 0) rot = -Math.PI / 3;
            ctx.rotate(rot);
            ctx.fillStyle = BLOCK_DEF[item].color; ctx.fillRect(10, -4, 20, 6);
            ctx.restore();
        }

        particles.forEach(p => { ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size, p.size); });
        
        ctx.restore();

        if (weather !== "NONE") {
            ctx.fillStyle = weather === "RAIN" ? "#64B5F6" : "#FFF";
            weatherParticles.forEach(p => { 
                let px = p.x % width; if(px<0) px+=width;
                ctx.fillRect(px, p.y, p.type==='rain'?2:4, p.type==='rain'?10:4); 
            });
        }
        if (damageFlash > 0) { ctx.fillStyle = `rgba(255, 0, 0, ${damageFlash})`; ctx.fillRect(0, 0, width, height); }
    }
</script>
</body>
</html>